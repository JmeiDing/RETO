article,highlights,id,attack
"securelist.com /diceyf-deploys-gameplayerframework-in-online-casino-development-studio/107723/ DiceyF deploys GamePlayerFramework in online casino development studioAuthorsKurt BaumgartnerGeorgy KucherinThe Hacktivity 2022 security festival was held at the MOM Cultural Center in Budapest, Hungary, over two days, October 6-7th 2022. One of several presentations by our GReAT researchers included an interesting set of APT activity targeting online casino development and operations environments in Southeast Asia. A recorded video of the presentation is already online. You can watch it here:All of our research, including a full set of IoCs and Yara rules, is written up in the two-part report “DiceyF Deploys GamePlayerFramework in Online Casino Development Studio”, already available to our private report subscribers. Some technical analysis from the report is provided here, along with a reference set of IoCs. You can find more information about trial and pay report subscription options at intelreports@kaspersky.com.url is at the tableWe call this APT “DiceyF”. They have been targeting online casinos and other victims in Southeast Asia reportedly for years now. Our research shows overlap with LuckyStar PlugX, a supply chain incident privately reported. TTPs, secure messaging client abuse, malware, and targeting demonstrate that this set of activity and resources align with Earth Berberoka/GamblingPuppet activity discussed at Botconf 2022 by Trend Micro researchers, also discussed as an unknown or developing cluster by other vendors. Prior to “Operation Earth Berberoka”, Trend Micro reported on “Operation DRBControl”, which also aligns with this activity and resource set.So, do we have another Ocean’s Eleven Clooney-Pitt duo targeting the largest casinos for shocking levels of criminality, revenge, and theft? No we don’t. In the related DiceyF incident that we report on, there was no evidence observed to date of immediate financial motivation or cash theft. Instead, previous incidents reported by TrendMicro researchers have exhibited customer PII database exfiltration and source code theft. Possibly we have a mix of espionage and IP theft, but the true motivations remain a mystery. Rolling the diceAn interesting combination of detections and characteristics sparked interest in this activity. These data points includedPlugX installers signed by a potentially stolen digital certificate from a secure messaging client development studio Malware distribution via an employee monitoring system and a security package deployment service Unusual .NET code signed with the same potentially stolen certificate and calling back to the same domain as the PlugX C2In November 2021, multiple PlugX loaders and payloads were detected in a network, which is often a wearisome topic to investigate. However, this time, the PlugX installer triad was deployed via two methods as an executable signed with a legitimate digital certificate — an employee monitoring service and a security package deployment service. This legitimate digital certificate appeared to have been stolen from a development and build studio for a secure messaging client. These PlugX payloads communicated with a C2 at apps.imangolm[.]com. Not much later, this same security package deployment service was used to push GamePlayerFramework downloaders, with these downloaders communicating with the same C2, and signed with the same digital certificate.Further research revealed a targeting profile suggesting an online casino development studio, and later, recruited/outsourced development systems on disparate networks. Waves of .NET downloader deployments followed and coincided with the PlugX deployments, signed by the same digital certificate.2/10These downloaders maintained PDB strings with “PuppetLoader” filepaths. These PuppetLoader strings pretty clearly connected the multistage loaders with past PuppetLoader downloaders, only this time, redesigned and rewritten in C#. Past PuppetLoaders, written in C++, maintain explicit strings:The new .NET code maintains similar strings, reflecting the previous codebase from several years ago.While these findings were being analyzed and reported, the folks from Trend Micro reported on GamblingPuppet/Earth Berberoka at Botconf, and we are confident that this DiceyF GamePlayerFramework activity is a subsequent campaign with a newly developed core malware set. This APT, DiceyF, aligns the previously reported GamblingPuppet and Operation DRBControl resources and activity, which we also observed in earlier data as well:PlugX and PuppetLoader multistage loader Online casino targeting in Southeast Asia Lack of evidence presenting a financial motivation (Trend Micro observed customer database and source code exfiltration in Operation DRBControl) Chinese language in use, particularly GamePlayerFramework error strings and plugin names and paths Data theft focus for backdoors includes keystrokes and clipboard Stolen digital certificate re-use Obscure secure messaging client as delivery vehicle for malware and cloak for malicious activityGamePlayerFramework is a complete C# rewrite of the previously mentioned PuppetLoader C++/assembly malware. This “framework” includes downloaders, launchers, and a set of plugins that provide remote access and steal keystrokes and clipboard data. The newer (summer 2022) executables are mostly all 64-bit .NET compiled with .NET v4.5.1, but some are 32-bit, or DLLs and compiled with .NET v4.0. There are at least two branches to this framework, “Tifa” and “Yuna”, and both branches maintain new modules, incrementally modified over time:D:\Code\Fucker\GamePlayerFramework\Tifa\*.pdb C:\Users\fucker\Desktop\Fucker\GamePlayerFramework\Tifa\*.pdb3/10D:\Code\Fucker\GamePlayerFramework\Yuna\*.pdbFinalFantasy code quirksPlayers may be familiar with the FinalFantasy game series, where Tifa and Yuna are two of the main characters. The Tifa and Yuna branches are different from one another: the Tifa branch includes only a downloader and a “core” module; the Yuna branch includes a downloader, plugins, and various PuppetLoader components, at least a dozen in total. Even the downloaders are fairly different from one another. As a matter of fact, the Yuna.Downloader code changes quite a bit over time, including with JSON parsing, logging, and encryption capabilities. Ongoing code development is on display here.The Tifa branch of code was deployed to victims first in November 2021, and these Tifa downloaders maintain more primitive functionality than the later Yuna downloaders. Additionally, it appears that code-signing coordination was not well organized in November. Except for one Tifa executable that was signed, two of the three Tifa downloaders were unsigned code, unlike the Yuna downloaders.The initial Tifa downloaders were already using “Mango” and “Mongo” function names just like artifacts found in Yuna downloaders, along with the aforementioned apps.imangolm[.]com C2 used by the PlugX implant. Later Yuna downloaders were distributed with the filename “mango.exe”. Two of the Tifa.Downloader variants introduced a “DownloaderVersion” string, likely for the attackers to maintain backwards compatibility on the server side. Some later Yuna.Downloader variants increase in functionality and complexity, but multiple early variants and the Tifa branch are quite simple. Loading the frameworkOnce downloaded and persistence set up, multiple components load the framework. The overall process of loading the framework can be summarized with the following graph:4/10This load sequence results in running the “Launcher” component. Despite the name, the main functionality of this module is not to perform launching. Instead, it is the orchestrator of the framework, i.e. it manages all the framework components. After completing the startup process, the orchestrator starts sending heartbeat packets to the C2 server every 20 seconds. Each such packet is a XOR-encrypted JSON object that contains the following information:Username of the logged-in user Current user session status (locked or unlocked) Size of logs collected by the clipboard recorder plugin Current date and timeThe C2 responds with one of fifteen commands.Command name Updates an internal timestamp with the last C2 response time Shuts down the framework Retrieves various system information, namely:Local network IP addresses Available privileges (SYSTEM, administrator or normal user) Network protocol used for C2 communication (hardcoded to Tcpv4 in all discovered samples) Framework version (in format yyyymmdd.xx, e.g. 20220506.00) Downloader module version CPU name5/10Available RAM Operating system version Address of the C2 server that is in use Size of clipboard recorder logs Installed security solution BIOS serial number MAC addresses Machine boot timeAllows execution of shell commands; this command creates a new cmd.exe process with redirected standard input and output and sends commands to it; the output of executed commands is sent back to the C2 server Sends the list of C2 servers specified in the configuration to the current C2 server Updates the list of C2 servers in the configuration by writing new C2 server addresses to the file C:\ProgramData\NVIDIA\DConfig Retrieves the version of a locally installed pluginDownloads a plugin from the C2 server and launches itRemoves the infection from the machine by creating a batch file that removes all files dropped by the framework installer except for rascustoms.dll; after performing removal, the batch file deletes itself Uploads a file from the victim machineDownloads a plugin from the C2 server but does not launch itLaunches a plugin on the victim machine, waiting until the plugin process finishes; in case of a timeout, the orchestrator kills the plugin process Either starts (if SubMsg is RunVirtualDesktop) or stops (if SubMsg is DestoryVirtualDesktop) the VirtualDesktop plugin If SubMsg is RunChromeCookie, launches the ChromeCookie plugin; if the argument string is GetCookiePath, returns the path where Chrome cookies are stored If SubMsg is RunFirefoxCookie, launches the FirefoxCookie plugin; if the argument string is GetCookiePath, returns the path where Firefox cookies are storedFastCmdCommand: command to be executedGetDomainSettingN/ASetDomainSettingDomainConfig: IP addresses and ports of new C2 serversGetRemotePluginInfo PluginName: name of an installed plugin PluginName: name of the plugin to be launchedRunPluginSessionId: ID of the session inside which the plugin is to be launchedDeleteGuidN/AFastDownloadCachePluginInstallPluginRemoteInjectChromeCookieFirefoxCookieFilePath: path of the file to be uploaded PluginName: name of the pluginPluginVersion: version of the plugin PluginName: name of the plugin to be launchedWaitForExitTimeout: timeout interval SubMsg: a string equal to [sic]SubMsg: a string equal to either RunChromeCookie or GetCookiePathSubMsg: a string equal to either RunFirefoxCookie or GetCookiePathPlugins overview6/10Plugins are EXE files that execute most of the framework’s malicious activities. Plugins can be configured to be downloaded from the C2 server when the framework starts up or is loaded at any other time using one of the commands above. During its execution, a plugin may connect to the C2 server and receive commands from it. Information about running plugins is stored in the C:\ProgramData\NVIDIA\DisplaySessionContainer1.ini file.All plugins of the framework are stored in a fileless way. Whenever a plugin is downloaded from the C2 server, it is loaded into the framework with the following procedure:The orchestrator selects a random port from 10000 to 20000 and launches a local TCP socket server on it. The orchestrator creates a new svchost.exe process in suspended mode and injects the api-ms-win-core-sys- l1-0-5.dll library mentioned in the “Loading the Framework” section. The injected library loads the PuppetLoader.Downloader component with the following arguments: -LoadName <plugin name> -PacketId <internal ID of the network packet with the plugin payload> -Port <server port generated at the first step>. The Yuna.PuppetLoader.Downloader component downloads the plugin executable from the local TCP server and loads it using Load.The strings of the orchestrator component reference the following plugin names:Plugin. (Acquisition System) Plugin. (Hidden Process) Plugin.SSH Plugin. (General Purpose Plugin) Plugin.SessionCmd Plugin. (Port Forwarding) Plugin. (Screen Transfer) Plugin. (Virtual Desktop) Plugin. (Clipboard) Plugin.ChromeCookie Plugin.FirefoxCookieWhile tracking deployments of GamePlayerFramework, we observed several plugins out of the list above being used: General Purpose Plugin, Clipboard and Virtual Desktop. Malicious app with graphical interfaceThe application deployed through installation packages of security solutions was designed to mimic an application that synchronizes data of the Mango messaging application. Below is the window displayed to the victim when this application starts:7/10Window of the malicious “Mango Employee Account Data Synchronizer”In order to make the victim user trust the malicious window, the attackers employed social engineering. As can be seen from the screenshot above, they included the name of the victim organization and even the floor where the organization’s IT department is located. At the same time, the visible window makes this application less suspicious to security solutions.When started, this application:Connects to the C2 server via a TCP socket. The address and port of the server is specified in the binary. In case connection fails, the application displays a message window with the “ ! IT!” text (“Unable to connect to Mango employee data synchronization server! Please report back to the IT department”). Sends the following information to the C2 server: Version of the installed Mango messenger Operation system version List of local IPv4 addresses Receives a JSON object containing a Boolean value named IsErrorMachine. If it is set to true, the application displays a message window with the “, 10IT” text (“Machines that have not been certified, please go to the IT department on the 10th floor to add machine certification”) and exits. Launches the exe executable located inside the same directory as the application. The internal name of this file is Yuna.Downloader.The code is under continuous incremental change and its versioning reflects a semi-professional management of the codebase modifications. Over time, the group added Newtonsoft JSON library support, enhanced logging, and encryption for logging. 2021-11-10 20473, AS- CHOOPA 20220506 20473, AS- CHOOPAAs described above, much of the early implants’ (both PlugX and the downloaders) communications activity calls back to infrastructure by resolving FQDN for infrastructure located in Southeast Asia. Later into April 2022, some of the Yuna.Downloaders began communicating directly with a hardcoded IP address. ConclusionThere are many interesting characteristics of DiceyF campaigns and TTPs. The group modifies their codebase over time, and develops functionality in the code throughout their intrusions.Organizations need to maintain solid efforts in monitoring software deployed across their organizations. The deployment systems themselves and the deployment process require heightened monitoring and maintenance: what gets deployed, when it gets deployed, and whose credentials are being used. The systems themselves need to be hardened and security products installed and updated.GamePlayerFramework enabled DiceyF, the actor behind this framework, to perform cyberespionage activities with some level of stealth. The initial infection method is noteworthy in that the framework is distributed via installation packages deployed through security solution control centers. Furthermore, the components of this framework are signed with a digital certificate that makes the framework more trusted by security solutions. In order to further disguise the malicious components, attackers added a graphical interface to some of them. Such implants are masqueraded as components of a messenger that is used at the victim organizations. To make sure that victims did not become suspicious of the disguised implants, attackers obtained information about targeted organizations (such as the floor where the organization’s IT department is located) and included it inside graphic windows displayed to victims. They also used service names, file paths, digital signing certificates, and other artifacts from NVIDIA, Mango, and other legitimate software. Plugins of GamePlayerFramework allow extensive monitoring of victim machines. For example, they are able to monitor keystrokes and the clipboard, browse websites located inside the organization’s local network, or establish virtual desktop sessions. And over the course of several months, DiceyF developers added more encryption capabilities to better hide their logging and monitoring activities. In the future, we expect to see an increase in the number of plugins and observe more unusual defense evasion methods in this framework.Finally, the deployment tactic used here isn’t quite as sophisticated as infecting an external component of the supply chain itself, but can be extremely effective. apps.imangolm[.]com archivess.imangoim[.]netPDB paths D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.Downloader\obj\Release\Yuna.Downloader.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.Launcher\obj\Release\Yuna.Launcher.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.Plugin.ClipboardRecorder\obj\Release\Yuna.Plugin.ClipboardRecorder.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.Plugin.General\obj\Release\Yuna.Plugin.General.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.Plugin.Installer\obj\Release\Yuna.Plugin.Installer.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.PuppetLoader.CodeLauncher\obj\Release\VpnSohDesktop.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.PuppetLoader.Downloader\obj\Release\Yuna.PuppetLoader.Downloader.pd D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.PuppetLoader.Guard\obj\Release\Yuna.PuppetLoader.Guard.pdb D:\Code\Fucker\GamePlayerFramework\Yuna\Yuna.PuppetLoader.ProcessLoader\obj\Release\Yuna.PuppetLoader.ProcessLoa10/10 ","The report analyzes cyberespionage activity by an APT group called DiceyF targeting online casinos and gaming companies in Southeast Asia. DiceyF uses phishing and malware to infiltrate networks and exfiltrate data. The initial infection involves weaponized Office documents that drop a multi-stage malware framework named GamePlayerFramework. There are at least two branches of the framework: Tifa and Yuna, each with its own set of modules and downloaders. This .NET malware features downloaders, orchestrators, and plugins for surveillance. The plugins steal keystrokes, clipboard data, screenshots, and credentials. GamePlayerFramework is an evolution of past malware like PuppetLoader used by DiceyF. The group continuously modifies the code, adding encryption and logging. The malware is signed with a stolen digital certificate to appear legitimate. Infrastructure analysis uncovered domains and IP addresses used for command and control. DiceyF registered lookalike domains imitating messaging apps and other software used by targets. Attribution is difficult, but tactics overlap with previous activity tracked as LuckyStar, Earth Berberoka, and GamblingPuppet. The targeting of online gaming suggests cyber espionage for intellectual property theft over financial crime. The report provides technical details on the infection routines, command and control, infrastructure, malware capabilities, and attribution. Comprehensive indicators of compromise are included. Defenders should focus on detecting Delivery documents, monitoring software deployment systems, and looking for the use of living-off-the-land binaries and stolen certificates. Gaming companies should confirm security controls and perform threat hunting to uncover DiceyF intrusions. ",train_552,code; GamePlayerFramework; Downloader; EXE; Malware; the C2; plugins; ID; remote access; Data theft; APT; keystrokes; clipboard data; credentials; information; the orchestrator; logs; commands; time; DiceyF; Updates; encryption; 10; payloads; PlugX; the Framework; 11; infrastructure; set; legitimate software; use; Persistence; version; the victim.
"SQUIRRELWAFFLE Leverages malspam to deliver Qakbot, Cobalt Strikeblog.talosintelligence.com/2021/10/squirrelwaffle-emerges.htmlBy Edmund Brumaghin, Mariano Graziano and Nick Mavis.Executive summaryRecently, a new threat, referred to as ""SQUIRRELWAFFLE"" is being spread more widely via spam campaigns, infecting systems with a new malware loader. This is a malware family that's been spread with increasing regularity and could become the next big player in the spam space.SQUIRRELWAFFLE provides threat actors with an initial foothold onto systems and their network environments that can then be used to facilitate further compromise or additional malware infections depending on how adversaries choose to attempt to monetize their access. In many cases, these infections are also being used to deliver and infect systems with other malware like Qakbot and the penetration-testing tool Cobalt Strike. Let's take a look at how this new threat operates and the volume and characteristics of the malicious email campaigns associated with it. Organizations should be aware of this threat, as it will likely persist across the threat landscape for the foreseeable future.1/16Email campaignsThe email threat landscape is constantly changing as new threats emerge or existing threats evolve over time. Over the past few years, Emotet has been one of the primary threats being delivered via malicious spam campaigns as we have previously described in detail several times. Following law enforcement disruption of the Emotet botnets, we've been waiting for another threat to fill the void left by Emotet's exit.Beginning in mid-September 2021, we observed malspam campaigns being used to deliver malicious Microsoft Office documents that function as the initial stage of the infection process and are used to infect systems with SQUIRRELWAFFLE. Similar to what has been observed in previous threats like Emotet, these campaigns appear to be leveraging stolen email threads, as the emails themselves appear to be replies to existing email threads. As shown below, these emails typically contain hyperlinks to malicious ZIP archives being hosted on attacker-controlled web servers.The language targeted by the reply messages typically matches the language used in the original email thread, demonstrating that there is some localization taking place dynamically. While the majority of the emails were written in English, the use of other languages across these campaigns highlight that this threat is not limited to a specific geographic region. Across the malicious email campaigns we have observed being used to deliver SQUIRRELWAFFLE, the top five languages used are as follows:2/16Consistent with other threats also leveraging stolen email threads, we observed some inconsistencies in how the attacker chooses which email chains to hijack. In the following example, the attacker was observed replying to an extortion email message, which is likely ineffective in convincing the recipient to access the content in the body of the email.Since the emergence of SQUIRRELWAFFLE, we have observed steady malicious email campaign activity associated with this threat. Below is a graph illustrating the volumetric trajectory of these campaigns between Sept. 1 and Oct. 15, 2021.3/16While the volume associated with these campaigns is not yet reaching the same level seen previously with threats like Emotet, it appears to be fairly consistent and may increase over time as the adversaries infect more users and increase the size of their botnet. The campaigns themselves feature several similar characteristics to the campaigns previously seen associated with established threats like Emotet. Due to the prevalence of these campaigns, organizations should be aware of SQUIRRELWAFFLE and the way it could be used by attackers to further compromise corporate networks.In all of these cases, the emails are designed to trick the potential victim into accessing the included hyperlink to download a malicious ZIP archive. Malicious Microsoft Office files are inside the archives, which initiate the infection process as described below.Infection processWhen the victim accesses the hyperlink contained in the initial malicious spam message, they are sent a ZIP archive containing a malicious Office document. While these documents have varied across campaigns, in all cases, they are either Microsoft Word documents or Microsoft Excel spreadsheets. These documents contain the malicious code responsible for retrieving and executing the next stage component, in this case, the SQUIRRELWAFFLE payload.Across all of the malspam campaigns observed, the distribution of DOC versus XLS was roughly 50/50.4/16In all of the campaigns observed, the distribution URLs that are used to host the malicious ZIP archives contain Latin words and follow a URL structure similar to the following example:abogados-en-medellin[.]com/odit-error/assumenda[.]zipWe've observed that, in many cases, there are separate ZIP archives being hosted in different directories on the same domain at any given point in time. Inside of the ZIP archives, the malicious Office documents often follow a naming convention similar to the examples below:chart-1187900052.xls diagram-127.doc diagram_1017101088.xls specification-1001661454.xlsSince these campaigns began, we observed several variations in the way the documents function, so will describe two of the most common infection chains we observed in September. This threat is actively evolving, and during our research into SQUIRRELWAFFLE, we observed the distribution campaigns' shift to almost exclusively using Microsoft Excel spreadsheets for this purpose.Malicious Word documentsAs previously described, the initial malicious Office document format used across many of the early email campaigns was a Microsoft Word document. In this case it was made to appear as if it was associated with DocuSign, a popular document sharing and signing platform that is often used for a variety of purposes related to official transactions.5/16In this particular case, the document contains malicious macros that initiate the SQUIRRELWAFFLE infection process if enabled by the victim. These macros are AutoOpen() and reference a macro function that contains the majority of the malicious code. Below is an example of one of these malicious functions present in one of the samples analyzed.As can be observed in the previous code, the macros leverage string reversal as a way to slightly obfuscate the contents of the code. This macro is responsible for writing a VBS script to %PROGRAMDATA% and then executing it. The contents of the malicious script can be seen in the following screenshot.6/16This script is responsible for the retrieval of the SQUIRRELWAFFLE payload itself from one of the five hardcoded URLs present in the script. In this case, SQUIRRELWAFFLE is delivered to the victim's system as a malicious DLL that is then executed using rundll32.exe.Malicious Excel spreadsheetsMany of the campaigns were observed using malicious Excel spreadsheets rather than Word documents.7/16These spreadsheets contain malicious Excel4 macros that are responsible for retrieving and executing the SQUIRRELWAFFLE payload. Below is an example of one of these macros that has been cleaned up to improve readability.Similar to what was observed with the Word document lures, these macros contain three hardcoded URLs that host the DLL associated with SQUIRRELWAFFLE. Once retrieved, the8/16DLL is executed via ShellExecuteA and regsvr32.exe, thus infecting the system. The ZIP archives and associated maldocs are rotated across emails, resulting in large quantities of unique samples. However, the SQUIRRELWAFFLE distribution URLs appear to be fairly common across samples for a given email campaign.Campaign timeline and variationsWe believe the earliest files used in these campaigns were submitted to public malware repositories on Sept. 10, 2021. The campaign volume began to ramp up on Sept. 13, 2021 and has been characterized by daily spam runs observed since then.In analyzing these campaigns, we observed some interesting characteristics associated with the infection chain. The URL structure of the SQUIRRELWAFFLE distribution servers appears somewhat tied to the daily campaigns, and rotates every few days. For example, the following table shows the variance in the URL landing pages seen over a period of several days.This rotation is also reflected in the maldoc macros themselves, with the macro function names and hashes rotating at the same time. This is reflected in the table below, which shows some of the macro function names, hashes and the corresponding campaign landing pages used by the macros to retrieve the SQUIRREWAFFLE DLL files observed across some of the initial malspam campaigns.These characteristics confirm that these documents are likely being crafted using an automated builder. In more recent campaigns, the Microsoft Excel spreadsheets were crafted to make static analysis with tools like XLMDeobfuscator less effective.9/16Distribution infrastructureThese malware distribution campaigns appear to be taking advantage of previously compromised web servers, primarily running versions of the WordPress content management system (CMS). Across the distribution servers we analyzed prior to host/domain suspension, the most prevalent version was WordPress 5.8.1.In one case, we also identified a SQL dump related to an AZORult panel present on the same host being used as a C2 server by SQUIRRELWAFFLE. As is often the case with vulnerable servers exposed to the internet, it is unclear whether this panel was being administered by the same threat actor or if the server had simply been compromised by multiple unrelated entities.One of the distribution servers also appeared to have had ANTIBOT deployed by adversaries on Sept. 8, 2021, shortly before the SQUIRRELWAFFLE distribution campaigns initially launched that made use of this server.ANTIBOT is a set of scripts commonly used as a component of phishing kits and can help actors evade analysis. This popular add-on will block access to the contents of their web servers if the HTTP/HTTPS requests originate from an IP address that is not determined to be a potential victim but is instead associated with automated analysis platforms, security research organizations, or other locations that attackers may want to avoid. When HTTP requests are received, the requestor is checked against several lists of IPs, ASN names and other artifacts. If any of the information matches, the server responds with an HTTP 404 status code. Below is an example of the logic used by this process. Note that the contents of each array have been redacted, as they are prohibitively long and could not be included in the screenshot. Typically, they contain large lists of IP addresses, network provider strings and more.10/16Combined with the IP blocklist present across many SQUIRRELWAFFLE DLLs, this demonstrates an effort to make the infrastructure more resilient and difficult to analyze. By limiting the ability for systems to retrieve malicious components, adversaries may more effectively evade large-scale automated analysis. Over time, the distribution infrastructure has become significantly more aggressive at restricting access to the malicious components and is employing techniques, like geographic-based filtering, to prevent analysis and tracking.SQUIRRELWAFFLE loaderThe SQUIRRELWAFFLE payload that is dropped on infected systems is a PE DLL that is executed using either rundll32.exe or regsvr32.exe depending on the maldoc used to initiate the infection process. Here's an example of the syntax used to execute the payload using rundll32.exe, specifying the entry point:cmd.exe /c rundll32.exe C:\ProgramData\[DLL FILENAME],ldrExecuting the DLL directly without specifying the required parameter will likely not result in successful execution of the payload and may allow it to evade automated dynamic analysis platforms.11/16The DLLs primarily function as a malware loader, enabling the infections to be used to deploy additional malware. SQUIRRELWAFFLE infections have been observed to coincide with Qakbot and Cobalt Strike installations following the initial compromise of the endpoint. The DLL also features an IP blocklist as part of its configuration that is used to attempt to further evade automated analysis platforms and security research organizations.The operation of the DLL is fairly straightforward. The most interesting functionality is used to encode and decode information to facilitate communications between the victim system and the C2 infrastructure. Below is a screenshot of the decompiled function responsible for this process.Additional information regarding the C2 protocol used by the malware can be found in the following section.Command and control (C2)The malware attempts to communicate with a C2 over HTTP POST requests containing obfuscated data:12/16The data present in these communications has been obfuscated using XOR and then Base64- encoded. The URL used by the victim to POST data to the C2 server consists of a random one- to 28-character alphanumeric string, followed by the IP address of the victim's system. The URL in the previous HTTP POST request can be deobfuscated to the following:The body of the HTTP POST request contains information about the victim system. The data sent to the C2 includes:%APPDATA% configuration. The hostname of the system. The username of the victim. The Workstation configuration of the system.This information is retrieved using getenv, GetComputerNameW, GetUserNameW, and NetWkstaGetInfo() respectively. An example of the deobfuscated request body of an example HTTP POST is shown below.13/16The C2 server will respond to these requests with a status code as well as the previously sent beacon information. The response body is obfuscated using the same method as previously described. An example response from C2 is shown below.This C2 channel is also used to deliver secondary payloads at the discretion of the attacker.14/16ConclusionA new malware loader named ""SQUIRRELWAFFLE"" has recently emerged in the threat landscape. This threat is primarily delivered via malicious spam email campaigns and features several interesting characteristics that organizations should be aware of. This malware is typically used to facilitate the delivery of additional malware such as Qakbot and Cobalt Strike, two of the most common threats regularly observed targeting organizations around the world. While this threat is relatively new, the distribution campaigns, infrastructure, and C2 implementations feature several interesting techniques that are similar to those seen from other more established threats. Organizations should continue to employ comprehensive defense-in-depth security controls to ensure that they can prevent, detect, or respond to SQUIRRELWAFFLE campaigns that may be encountered in their environments.CoverageWays our customers can detect and block this threat are listed below. Cisco Secure Endpoint (formerly AMP for Endpoints) is ideally suited to prevent the execution of the malware detailed in this post. Try Secure Endpoint for free here.Cisco Secure Email (formerly Cisco Email Security) can block malicious emails sent by threat actors as part of their campaign. You can try Secure Email for free here.Cisco Secure Firewall (formerly Next-Generation Firewall and Firepower NGFW) appliances such as Threat Defense Virtual, Adaptive Security Appliance and Meraki MX can detect malicious activity associated with this threat.Cisco Secure Malware Analytics (Threat Grid) identifies malicious binaries and builds protection into all Cisco Secure products.Umbrella, Cisco's secure internet gateway (SIG), blocks users from connecting to malicious domains, IPs and URLs, whether users are on or off the corporate network. Sign up for a free trial of Umbrella here.Cisco Secure Web Appliance (formerly Web Security Appliance) automatically blocks potentially dangerous sites and tests suspicious sites before users access them.15/16Additional protections with context to your specific environment and threat data are available from the Firewall Management Center.Cisco Duo provides multi-factor authentication for users to ensure only those authorized are accessing your network.Open-source Snort Subscriber Rule Set customers can stay up to date by downloading the latest rule pack available for purchase on Snort.org.The following Snort SIDs have been released to detect this threat: 58277 - 58281.The following ClamAV signatures have been released to detect this threat:Doc.Downloader.SquirrelWaffle09210-9895192-0 Xls.Downloader.SquirrelWaffle20921-9895790-0 Xls.Downloader.SquirrelWaffle1021-9903731-0Orbital QueriesCisco Secure Endpoint users can use Orbital Advanced Search to run complex OSqueries to see if their endpoints are infected with this specific threat. For specific OSqueries on this threat, click here.Indicators of Compromise (IOCs)The following indicators of compromise have been observed associated with these malware campaigns.DomainsA list of domains observed being used in these malware campaigns can be found here.Hashes (SHA256)here.16/16 ","The PDF describes the emergence of a new malware threat called SQUIRRELWAFFLE that is being spread through spam email campaigns. SQUIRRELWAFFLE provides an initial foothold on systems that can then be used to install additional malware like Qakbot and Cobalt Strike. The campaigns started in mid-September 2021 and leverage stolen email threads, replying to them with malicious links to ZIP archives containing weaponized Office documents. The emails are localized based on the original language. The malicious documents contain macros or scripts that download and execute the SQUIRRELWAFFLE payload, which is a DLL that functions as a malware loader. The infrastructure uses compromised WordPress servers and techniques like IP blocklists and ANTIBOT to evade analysis. The DLL payload communicates with a C2 server using obfuscated HTTP requests to exfiltrate system info and receive commands. SQUIRRELWAFFLE has been used to deliver Qakbot and Cobalt Strike in follow-on infections after the initial compromise. The PDF provides technical details on the infection process, document macros, C2 communications, and distribution infrastructure. It concludes that organizations should employ defense-in-depth security to prevent, detect, and respond to SQUIRRELWAFFLE campaigns as this threat is expected to persist. Indicators of compromise and detection signatures are provided. ",train_1066,the attacker; emails; ZIP archives; Office; the victim; Word; Excel; the document; malicious macros; scripts; the macros; SQUIRRELWAFFLE; the DLL; rundll32; regsvr32; the system; the C2 server; HTTP POST requests; Command; secondary payloads; Qakbot; Cobalt Strike; further compromise.
"Cloud Snooper - SophosLabsPage 0 of 29Cloud Snooper - SophosLabsCloud Snooper attack An investigation of an attack in progress on a cloud computing server reveals an unusual and innovative way for malware to communicate through firewallsSergei ShevchenkoCloud Snooper - SophosLabsPage 1 of 29Cloud Snooper - SophosLabsContentsRootkit in the Cloud 3Anomalous traffic raises alerts 3Dismantling the Cloud Snooper tools 3The Cloud Snooper communications handler 5How Cloud Snooper communicates through the firewall 5Practical examples of communication with the Snooper 6Explaining the attack: Wolves in sheep's clothing 9Technical analysis of Cloud Snooper network operations 11Sample #3 13Logging 15Some additional details on unused/broken 'rootkit' functionality 16Building a Client 17Another variant of the rootkit 18Sample #4 18Sample #5 19Sample #6 19Sample #7 20Sample #8 21Sample #9 22Windows Malware 23Sample #10 23Sample #11 - encrypted payload 23Conclusion 28IOCs 28Cloud Snooper - SophosLabsPage 2 of 29Cloud Snooper - SophosLabsRootkit in the CloudIn the course of investigating a malware infection of cloud infrastructure servers hosted in the Amazon Web Services (AWS) cloud, SophosLabs discovered a sophisticated attack that employed a unique combination of techniques to evade detection and that permits the malware to communicate freely with its command and control (C2) servers through a firewall that should, under normal circumstances, prevent precisely that kind of communication from reaching the infected server.Though we discovered the technique in use on AWS, the problem is not an AWS problem per se. It represents a method of piggybacking C2 traffic on a legitimate traffic, such as normal web traffic, in a way that can bypass many, if not most, firewalls.The complexity of the attack and the use of a bespoke APT (Advanced Persistent Threat) toolset gives us reason to believe that the malware and its operators were an advanced threat actor, possibly nation- state sponsored.The compromised systems were running both Linux and Windows EC2 instances.Anomalous traffic raises alertsAs often happens with incidents like this, our investigation started when someone noticed an anomaly. While the AWS Security Groups (SGs) were properly tuned, set up to only allow inbound HTTP or HTTPS traffic, the compromised Linux system was still listening for inbound connections on ports 2080/TCP and 2053/TCP.An analysis of this system revealed the presence of a kernel-level rootkit that granted the malware's operators the ability to remotely control the server through the AWS SGs. But this rootkit's capabilities are not limited to doing this in the Amazon cloud. It could also be used to communicate with, and remotely control, malware on any server behind any boundary firewall – even an on-premises server.By unwinding other elements of this attack, we further identified other Linux hosts infected with the same or a similar rootkit.Finally, we identified a compromised Windows system with a backdoor that communicated with a similar C2 as other compromised Linux hosts, using a very similar configuration format. The backdoor is apparently based on source code of the infamous Gh0st RAT malware.At this point in the investigation, we still have some open questions. For example, it is still unclear how the attackers managed to compromise the client's system in the first place. One of the working theories is that the attackers broke into a server through SSH protected with password authentication.Dismantling the Cloud Snooper toolsAs you will see from the description below, some samples we collected are directly related to each other, while others belong to a completely different malware family. Nevertheless, all these samples were collected from the same infrastructure, and thus, we consider them part of the same toolset.Even though some questions remain, we believe it's important to share all the evidence we have collected with the security community, network administrators, and researchers to raise awareness of this attack.Cloud Snooper - SophosLabsPage 3 of 29Cloud Snooper - SophosLabsThe description starts with the Linux malware, then progresses into its Windows counterpart that is apparently based on Gh0st RAT.Overall, we discovered and studied 10 samples in the course of the investigation, which can be broken packet filter, using a Netfilter hook (NF_INET_LOCAL_IN and NF_INET_LOCAL_OUT).This component was instrumental in giving the malware's operators the ability to communicate with the malware, despite the firewall protecting the AWS EC2 servers.The two nearly identical samples of snd_floppy (file snd_floppy.ko) recovered from two different namesnd_floppyHow Cloud Snooper communicates through the firewallThe NF_INET_LOCAL_IN is a type of hook that is triggered before the packet reaches the destination port.The installed hook handler inspects the socket buffer of every IPv4 packet, looking for a command concealed within a header – the command being the source port number of the packet originating from the attacker's machine.Cloud Snooper - SophosLabsPage 5 of 29Cloud Snooper - SophosLabsAn analysis of the malware samples reveal that it is looking for packets that use any of the following source ports. Each unique source port represents a command, such as: 1010, 2020, 6060, 7070, 8080, or 9999.Firewalls typically prevent machines behind the firewall from receiving traffic sent to arbitrary destination ports, but they don't pay attention to the source ports, because source ports are normally ephemeral, and not relevant to the server or the services it is hosting.In a typical cloud instance, the server may be set up to receive traffic from any IP address on port 80/TCP (for HTTP) and on 443/TCP (for HTTPS), so the firewall will let any traffic to those ports through to the server. So long as the traffic coming in to one of these standard ports fits the pattern the communications handler is looking for, it will execute one of its built-in instructions. Anything else will be ignored, and the server will serve web pages as normal to browsers.Practical examples of communication with the SnooperFor example, if the communications handler receives a TCP SYN packet with an origin port of 6060, the malware will decrypt an embedded file (SHA-256: with RC4 (the key is 'YaHo0@').It will then drop that decrypted file as /tmp/snoopy, wait for half a second, and then execute it as a usermode application with the call_usermodehelper() syscall. Immediately after that, it deletes the /tmp/snoopy file, so the snoopy application remains running in memory with no physical file present.The commands passed to two consecutive call_usermodehelper() syscalls are:/bin/sh -c /tmp/snoopyrm -rf /tmp/snoopyThe commands above will run and then delete the file from the filesystem, but an active snoopy process listening on ports 2053 and 2080 remains:If the command is 9999 as a TCP SYN packet, the /tmp/snoopy process self-terminates (in case killall is supported by OS), by passing the following commands to call_usermodehelper() syscall./bin/sh -c /tmp/snoopyrm -rf /tmp/snoopykillall /tmp/snoopyNOTE: executing snoopy again while it's already running has no effect; by using a file lock mechanism, snoopy makes sure only one instance is running. If that happens, it will output:[ERROR] there is already a instance.Cloud Snooper - SophosLabsPage 6 of 29Cloud Snooper - SophosLabsHere is the logic of the NF_INET_LOCAL_IN hook handler, which listens for SYN packets sent to the server, using the various source ports:if tcp:if tcp.src_port == 6060:if tcp.flags == SYN:drop_payload() # drops/runs snoopyreturn NF_STOPelif tcp.src_port == 7070:tcp.dst_port = 2080adjust_tcp_checksum()return NF_STOPelif tcp.src_port == 9999:if tcp.flags == SYN:kill_payload() # kills snoopy processreturn NF_STOPelif tcp.src_port == 2020:return NF_STOPelif tcp.src_port == 1010:tcp.dst_port = 22adjust_tcp_checksum()return NF_STOPelse:return NF_ACCEPTelif udp:if udp.src_port == 8080:udp.dst_port = 2053adjust_udp_checksum()return NF_STOPelse:return NF_ACCEPTAnd here is the logic of the NF_INET_LOCAL_OUT hook handler:if tcp:if tcp.dst_port == 7070:tcp.src_port = 443 # or, 80 in another variantCloud Snooper - SophosLabsPage 7 of 29Cloud Snooper - SophosLabsadjust_udp_checksum()return NF_STOPif tcp.dst_port == 2020:return NF_STOPif tcp.dst_port == 1010:tcp.src_port = 443 # or, 80 in another variantadjust_udp_checksum()return NF_STOPelse:return NF_ACCEPTelif upd:if udp.dst_port == 8080:udp.src_port = 53return NF_STOPelse:return NF_ACCEPTCloud Snooper - SophosLabsPage 8 of 29Cloud Snooper - SophosLabsExplaining the attack: Wolves in sheep's clothingIn the illustration above, our castle represents the targeted server infrastructure; In the case of the incident we investigated, the server was hosted by Amazon Web Services (AWS). At its perimeter, the AWS Security Groups - a set of firewall rules that provide security at the protocol and port access level – limit the inbound network traffic.For example, you might typically set up an AWS Security Group that only allows web traffic – that is, TCP packets that arrive at ports 80 or 443 – to reach your server. Network traffic with any other destination port never makes it past the SGs.The infection involves a rootkit that inspects network traffic, and a backdoor that the attackers leverage the rootkit to send commands to, and receive data from, the backdoor.Cloud Snooper - SophosLabsPage 9 of 29Cloud Snooper - SophosLabsIn order to bypass the AWS Security Groups, depicted here as guards, the attackers communicate with the rootkit by sending innocent-looking requests (depicted in the illustration as a wolf in sheep's clothing) to the web server on the normal web server ports. A listener that inspects inbound traffic before it reaches the web server intercepts the specially-crafted requests, and sends instructions to the malware based on characteristics of those requests.Cloud Snooper - SophosLabsPage 10 of 29Cloud Snooper - SophosLabsThe listener sends a ""reconstructed"" C2 command to the backdoor Trojan installed by the rootkit. Depending on the commands included into C2 traffic, the attacker may use the backdoor to steal sensitive data from the target.The collected data is then delivered back with the C2 traffic. Only this time, the rootkit has to masquerade it again in order to bypass the guards: the wolf dresses itself in sheep's clothing once again. Once outside, the C2 traffic delivers the collected data back to the attackers.During an entire operation, the normal web traffic, depicted as sheep, keeps flowing to and from the web server through the allowed gate. Visually, the C2 traffic stays largely indistinguishable from the legitimate web traffic.Technical analysis of Cloud Snooper network operationsTo trigger the payload (snoopy) activation, an attacker would send the following packet:Cloud Snooper - SophosLabsPage 11 of 29Cloud Snooper - SophosLabsNext, the snoopy module would be accessed by the C2, using source port 7070 for TCP-based or 8080 for UDP-based control:On the way back, the NF_INET_LOCAL_OUT hook handler rebuilds the packet again to make sure its source port is restored back to the original port the incoming packet was destined for. This way, the C2 traffic transparently flows through the port(s) allowed by the firewall:No other Netfilter hooks within the chain, such as iptables INPUT/OUTPUT rules, will process the packet if the hook returns NF_STOP. This appears to be the purpose of the TCP command 2020: to bypass other Netfilter hooks.In instances where the Netfilter receives inbound traffic with a source port of 1010/TCP, it directs the contents to the Secure Shell (SSH) port, 22/TCP. For outbound traffic, we have seen two variants using either port 80 or port 443. This will allow for an SSH connection to step around a firewall with IP restrictions on traffic to port 22.Cloud Snooper - SophosLabsPage 12 of 29Cloud Snooper - SophosLabsHence, the ultimate purpose of the snd_floppy rootkit is to provide a covert control channel for the snoopy usermode process, running on a compromised host.Such covert control channels can be established via any port allowed by firewalls or AWS Security Groups, be it 80, 443, 22, or any other port.From the outside, the compromised system will show an unusually large volume of traffic that comes namesnoopy is a backdoor trojan that can be executed both as a command line tool and as a daemon (though it needs to be launched with the -d flag for that). The backdoor's internal version is 3.0.1-2.20170303.It opens HTTP and/or DNS services on a compromised system, and allows tunneling of the traffic, operating both as a reverse SOCKS5 proxy server, and client.For example, the incoming control traffic can also be relayed to a different server.When run with -h option, the tool prints the following syntax:Usage: rrtserver [OPTIONS]OPTIONS:-h-d-s IPv4[:PORT:{udp|tcp}:{dns|http|none}]Where:-h option will print out the usage above-d will run the tool as daemonCloud Snooper - SophosLabsPage 13 of 29Cloud Snooper - SophosLabs-s allows to specify a server address to bind the listening socket to, its port number, and what protocol is used for the traffic: either UDP-based DNS or TCP-based HTTPThe binary requires root privilege; when run, it calls geteuid() to get the user ID. If it fails, it prints the line below and quits:""Administrator privileges are required.""It sets the working directory to /tmp and obtains a lock for the file /tmp/rrtserver-lock. The lock file is used to make sure there is only one version of the tool running.The incoming HTTP traffic is accepted on port 2080, and DNS traffic on port 2053.NOTE: the port numbers 2080 and 2053 are default ones; the tool can be executed with different port numbers specified as parameters.The rootkit parses the received DNS/HTTP traffic to extract hidden commands within it - such commands are called ""rrootkit messages"" and are distinguished by the presence of a magic header or marker.For example, to find ""rrootkit messages"" in HTTP traffic, Snoopy parses the HTTP request to see if it starts with ""GET /* HTTP/1.1\r\ndata:"" or ""HTTP/1.1 200 OK\r\ndata:"".Next, the ""rrootkit messages"" would start from a magic header 0xE381B7F5. If this header is found, such data is called msg-data.The received msg-data is then decrypted with RC4, using the quite specific key 'A YARN-based system for parallel processing of large data sets'.The tool then initiates several additional components. These components will process the received msg- data.Depending on a separate magic header within each msg-data, the data will be processed by a different component.The initiated components are:• view-shell (magic header 0xFC72E392): pty (pseudo terminal) that allows remote shello othe HISTFILE variable is cleared, to make sure /bin/sh execution leaves no history the received commands are then executed with /bin/sh• view-file (magic header 0xFC72E393): file manager that accepts three commands:'get' - read files 'put' - save fileo o o any other command - execute file with popen() syscall• view-proxy (magic header 0xFC72E394): proxy server that accepts the following commands:o oo'exit' or 'quit' - quit proxy server 'socks5' - starts SOCKS5 proxy server, authentication is provided with user/password passed with the '-u' and '-p' parameters 'rcsocks-cmd: socks is closed.' - closes SOCKS proxyThe SOCKS5 server is based on the open-source sSocks proxy implementation:Cloud Snooper - SophosLabsPage 14 of 29Cloud Snooper - SophosLabssSocks is a package which contains: a socks5 server implements RFC 1928 (SOCKS V5) and RFC 1929 (Authentication for SOCKS V5), a reverse socks server and client, a netcat like tool, which supports socks5 with authentication and a socks5 relay (run a server and send to a another socks5 server).• view-pipe (magic header 0xFC72E398): p2p communicator, that receives commands 'pwd', 'exit', 'quit','connect'On receiving the 'connect' command, it accepts the same parameters as the command-line tool (server IP, port, protocol) and starts tunneling commands to another peer.The pipe appears to be used to establish connections to other peers.The negotiation protocol to other peers includes a message 'rrootkit-negotiation: hello'.Once the connection is established, the logged message displays what peers have been connected, and that a new network node is now open:""view-pipe: left[address, port]->right[address, port].""""view-pipe: the network node is opened.""• view-myproto (magic header 0xFC72E397): a 'ping'/'pong'; depending on a flag it receives, it either:oreceives a message ""rrootkit-negotiation: hello"", then responds back ""rrootkit-negotiation: ok, go on""o checks if the received message was ""rrootkit-negotiation: ok, go on""•loop-notifier – creates a pipe, a data channel for inter-process communication (IPC) The backdoor allows control via IPC pipe as a backup control channel.Loggingsnoopy stores many debug messages in clear text.However, with the internal level of logging set to 0 (none), no debug messages are ever printed. Hence, these debug messages are only used in the testing phase of the malware.Some of the debug messages are in Chinese:• ! - The remote path is too long!• ! - The remote file does not exist!• ! - Remote memory space allocation failed!• ! - The remote path does not exist!• ! - The remote file already exists!• ! - Connection failed!Cloud Snooper - SophosLabsPage 15 of 29Cloud Snooper - SophosLabs• ! - Connection succeeded!• ! - Parameter error!Some messages reveal poor English grammar:• view don't found • view-shell: data do not belong to SHELLIf the rootkit is patched so that it always logs debug messages, it will happily print them on screen:Some additional details on unused/broken 'rootkit' functionalityThe tool has an unused (never called) function kernel_load() to drop and load kernel module from its own file. If the module /proc/sys/rrootkit is missing, it drops /tmp/rrtkernel.ko and loads it with:insmod /tmp/rrtkernel.ko 2>/dev/nullNext, /tmp/rrtkernel.ko is unlinked, so it's used, temporarily, to drop and then load a kernel module.The function kernel_load() is never called though - there are no references leading to it.Apart from that, /tmp/rrtkernel.ko is written by reading its own binary file, starting from the file offset of nearly 2GB:readlink(""/proc/self/exe"", pathname, 0x200uLL);myfd = open(pathname, 0);lseek(myfd, g_self_size, SEEK_SET); // file offset is set to offset byteswhere g_self_size is set to 0x72C9E41D:g_prev_self_size_mark dd 0EF71B69Ah // unusedg_self_size dd 72C9E41Dh // <-- nearly 2GBg_post_self_size_mark dd 33FF0055h // unusedThis code will not work - even if this function was called (it wasn't), it would have failed.Cloud Snooper - SophosLabsPage 16 of 29Cloud Snooper - SophosLabsIt would appear the author was tossing around the idea of dropping and loading a kernel module from its own file. There are two unused variables 'prev self size mark' and 'post self size mark' which might indicate some experiments the author has attempted.The original intention is not clear. However, the presence of markers 'prev self size mark' and 'post self size mark' around the file offset variable is intriguing.The markers could be used to find the exact location of the offset in the binary:This way, an external patcher could find and modify the actual offset from where the kernel module could be read, saved, and loaded. For example, if it's set to the end of the snoopy binary, the kernel module can thus be read and loaded from the appended data.However, this feature wasn't implemented, and should, therefore, be considered experimental.Building a ClientBy knowing how the C2 protocol works, it is possible to build a client to talk to snoopy either directly, or via snd_floppy rootkit.What for?Firstly, the client can ping a host located in the same network to see if it's infected or not.Secondly, if a host is infected, the client can disinfect it remotely by instructing snoopy to execute its disinfection routine (see the rmmod command below – after serving it, the rootkit stopped responding as it was unloaded).Last but not least, building such a client is cool.The following screenshot demonstrates the client in action. The snd_floppy rootkit intercepts traffic on port 22, even though it's destined for the SSH daemon (seen as 981/sshd in the snapshot below). Next, it re-routes such traffic internally to the snoopy module.Cloud Snooper - SophosLabsPage 17 of 29Cloud Snooper - SophosLabsAs long as the rootkit is active, the attackers may attempt to smuggle the control traffic through any port allowed by the firewall (the screenshot demonstrates that using ports 21 and 24 makes no difference – these packets are still re-routed by the rootkit to the backdoor).Another variant of the rootkitDuring the investigation, a different Linux host was found to be running a different variant of the nameThis kernel module is very similar to the variant described above. The embedded resource is encrypted name/bin/vsftpd in this case is not a well-known FTP server daemon but a backdoor that listens on port 2080.The communications are encrypted with a custom algorithm based on AES and an additional XOR round. Key initialization is based on hashing the string ""replace with your password"" and a key received from the server, hashed with SHA-1.The bot can execute three commands, encoded with integer numbers 1 to 3:1:download specified fileinternal name: tshd_get_file()2:upload file and save it under a specified file nameinternal name: tshd_put_file()3:execute remote shell command with /bin/shinternal name: tshd_runshell()A different version of vsftpd, a backdoor, recovered as a file named ips, was found to be listening on nameipsCloud Snooper - SophosLabsPage 19 of 29Cloud Snooper - SophosLabsThe presence of ips suggests that another 32-bit version of snd_floppy that redirects incoming traffic into port 10443 may exist.The samples #1-#6 described above represent a combination of a rootkit and a passive backdoor that accepts connections on an open port.Sample #7Apart from those samples, we have also recovered a different Linux backdoor, a backdoor that does not open any ports. Instead, it relies on a C2 polling mechanism.The analysis of this bot functionality reveals it belongs to Gh0st RAT, only it's a version that has been written for Linux.It is hard to tell if Gh0st has always existed as a multi-platform RAT, or whether the attackers developed a Linux-based Gh0st after the source code of Gh0st for Windows was leaked online.At the end of the day, it makes sense to have clients deployed across various platforms, using a unified configuration format and C2 protocol, while having a single server for all those clients.Still, we will leave the guesswork out of this description, rather focusing on what the recovered samples should match what's in config.If there is no match, the bot falls asleep for just over seven minutes (423.756 seconds), then checks the time again.In case of a match, it attempts to reach the C2; if it cannot, it retries again in one minute.Cloud Snooper - SophosLabsPage 20 of 29Cloud Snooper - SophosLabsTraffic to the C2 is encrypted with double RC4, where a key is randomly generated based on the current time.The backdoor has six commands:• The bot clears environmental variable HISTFILE to make sure no history is kept for/bin/bash execution; the C2 responds with a string, and the bot sets TERM variable to that returned stringNext, it receives a command and executes it with /bin/bash, with or without a '-c' switch (allows for executing commands as provided within the quotes)The output from the executed command is sent back.• File manipulations:o Locate and obtain timestamp for the specified file o Rename specified file o Recursively delete all files in the specified directory• More file manipulations:o Read the contents of the specified file o Recursive search for files o Write data into a specified file o Create specified directory• The next two commands manipulate file descriptors with fcntl() syscall, and fork child processes • Receive data and save it into a local file /usr/include/sdfwex.hIt appears that /usr/include/sdfwex.h contains a timestamp (year, month, day, hour, minutes) for when the C2 connection should commence.If the bot cannot open this file, it tries to open /tmp/.llock – if that file also cannot be opened, the bot configuration:cloud.newsofnp.com:443;|1;1;1;1;1;1;1;|00-24;|1An analysis of network activity revealed that a similar domain – ssl.newsofnp.com was also resolved matches the configuration file and falls asleep for exactly 423.756 seconds (just over seven minutes) before it tries again.For the beacon signal it sends to the C2, it collects basic system configuration into a fingerprint. This info consists of:• Hostname and IP address • Platform type, as read from /proc/version, such as 'x86_64' • Full name of the Linux version, as read from /etc/issue.net and /etc/issue, such as:'Red Hat Enterprise Linux Server release 6.10 (Santiago)'or 'Ubuntu 16.04.5 LTS'Cloud Snooper - SophosLabsPage 22 of 29Cloud Snooper - SophosLabsThe communications with the C2 are always encrypted using a bespoke algorithm that relies on a time- based random RC4 key with extra encryption layers.The backdoor commands received from the C2 and executed by nood.bin fully match /bin/snort functionality. That is, it provides remote shell and a dedicated remote file manipulation capability, such Provider.""NOTE: 'Netword' with 'd'.Cloud Snooper - SophosLabsPage 23 of 29Cloud Snooper - SophosLabsThe DLL is heavily obfuscated.Once started as a service, it conveniently spits out debug messages documenting the operation.Sysinternal's DebugView shows these messages:00000000 000000090.00000000 [4052] DLL_PROCESS_ATTACH. 0.00489140 [4052] Rundll32Entry() 0.01733349 [4052] ServerLoadPayload() 0.01749189 [4052] Get Module File Name. 0.01753826 [4052] Get Payload File Name. 0.01757095 [4052] Switch to payload directory. 0.01768074 [4052] Read Payload File. 0.01811264 [4052] Decrypt Payload Data. 0.06122175 [4052] Verify Payload Data. 0.06732560 [4052] ServerExecutePayload()000000100.06740102 [4052] Call Shellcode.Once loaded, the DLL locates the encrypted payload file and loads it into memory.The steps are:• Get current module filename with GetModuleFileName() API, i.e.%PATH%\NSIProvider.dll• Concatenate current module filename with '.crt', e.g. %PATH%\NSIProvider.dll.crt • Allocate memory VirtualAlloc() and read the entire payload file into memory •Initialise a permutation table that consists of 256 DWORDs Each value of the permutation table is calculated as:*ptr= ((*ptr >> 1) & 0x54384748 | ~(*ptr >> 1) & 0xABC7B8B7) ^ 0x467F3B97; PERM_TABLE[*index] = *ptr;• Start decryption loop – in this loop, a key value is subtracted from each byte of the encryptedpayload; the key value itself is calculated in each iteration based on the previous key value, current index of the decrypted byte, and the permutation table:Cloud Snooper - SophosLabsPage 24 of 29Cloud Snooper - SophosLabsptr = __ptr_index++; val = PERM_TABLE[((*ptr & 0x67612505 | ~*ptr & 0x989EDAFA) ^ (KEY & 0x67612505 | ~KEY & 0x989EDAFA)) & ((*ptr & 0x67612505 | ~*ptr & 0x989EDAFA) ^ (KEY & 0x67612505 | ~KEY & 0x989EDAFA) ^ 0xFFFFFF00)];KEY = (val & 0x432AA81D | ~val & 0xBCD557E2) ^ ((KEY >> 8) & 0x432AA81D | ~(KEY >> 8) & 0xBCD557E2);• The decrypted payload reveals a checksum, a number of zero bytes, followed by the initialshellcode itself:The decrypted payload blob is copied into a newly allocated memory buffer and the initial shellcode (starts from bytes EB 17 58 in the image above) is called.The initial shellcode will then decrypt the rest of the blob using an XOR key that starts from 0x2B, and then incremented by the index of the decrypted byte, i.e. the XOR key values are: 0x2B, 0x2C, 0x2E, 0x31, etc.As the rest of the blob is decrypted, the configuration file is decrypted as well, followed by other parts.After the initial shellcode has finished the decryption, the fully decrypted blob will consist of:Initial shellcode- - Decrypted config:Microsoft.Windows.BNG| 24;|1ssl.newsofnp.com:443;|1;1;1;1;1;1;1;|00-- Zlib-compressed LIBEAY32.dll (77,871 bytes, 167,936 bytes when decompressed) - Zlib-compressed LIBEAY32.dll (386,876 bytes, 851,968 bytes when decompressed) - Backdoor, implemented in the form of a second-stage shellcodeOnce it's decoded, the second-stage shellcode is called – this is the backdoor itself.Cloud Snooper - SophosLabsPage 25 of 29Cloud Snooper - SophosLabsWhen it gets control, it dynamically obtains all the APIs it needs by using hard-coded API hashes. To find matching hashes from the API names, the shellcode relies on a slight modification of the ROR-13 algorithm. The only difference is that it checks if the zero byte character is at the end of the loop, and thus has an additional ROR for the terminating zero byte.All the required DLLs are loaded dynamically.Next, it will decompress and load two stubs as DLLs. Both DLLs have the internal name LIBEAY32.dll.Both DLLs rely on an older (2004) build of the libeay32.dll. Below are some strings found in the body of these DLLs:MD2 part of OpenSSL 0.9.7d 17 Mar 2004 MD4 part of OpenSSL 0.9.7d 17 Mar 2004 MD5 part of OpenSSL 0.9.7d 17 Mar 2004 SHA part of OpenSSL 0.9.7d 17 Mar 2004 SHA1 part of OpenSSL 0.9.7d 17 Mar 2004The backdoor relies on these DLLs for crypto-functions required to communicate with the C2.The config format is consistent with the ELF binaries, i.e., the seven '1;' means the bot should be active seven days a week, all hours (00-24), the C2 communicates via HTTPS.The. sSame config is known to be used by the Gh0st RAT.Just like /bin/snort described above, the bot also checks if the current day and hour match what's specified in the config.If there is no match, the bot also falls asleep for just over seven minutes (423.756 seconds), then checks the time again.The code snippets below demonstrate that the 423,756-millisecond delay specified within /bin/snort executable is identical to its Windows counter-part:ELF executable: /bin/snortWindows shellcode:Cloud Snooper - SophosLabsPage 26 of 29Cloud Snooper - SophosLabsOn Linux, the number 423,756 is multiplied by 1,000, then passed to usleep() syscall that takes an argument in microseconds.On Windows, the same number is passed to Sleep() API, which takes the argument in milliseconds.In both cases, the achieved delay is identical: 7.062 seconds.Cloud Snooper - SophosLabsPage 27 of 29Cloud Snooper - SophosLabsConclusionThis case is extremely interesting as it demonstrates the true multi-platform nature of a modern attack.A well-financed, competent, determined attacker will unlikely ever to be restricted by the boundaries imposed by different platforms.Building a unified server infrastructure that serves various agents working on different platforms makes perfect sense for them.When it comes to prevention against this attack (or similar ones), AWS Security Groups provide a robust boundary firewall for EC2 instances. However, this firewall does not eliminate the need for network administrators to keep all external-facing services fully patched.The default installation for the SSH server also needs extra steps to harden it against attacks, turning it tainting kernel""Cloud Snooper - SophosLabsPage 29 of 29 ","This document mainly introduces the working principle and analysis process of the network security tool Cloud Snooper. Cloud Snooper is a network monitoring tool for detecting and defending against various network attacks. The tool communicates through the firewall using a hook called NF_INET_LOCAL_IN, which inspects the socket buffer of each IPv4 packet for command information. The installed hook handler uses a configuration file to determine which source ports to look for in the packets. Each unique source port represents a command, such as 1010, 2020, 6060, 7070, 8080, or 9999. Firewalls typically prevent machines behind the firewall from receiving traffic sent to arbitrary destination ports, but they don't pay attention to the source ports because they are ephemeral and not relevant to the server or services it is hosting. During the investigation, a different rootkit variant was found, which was very similar to the previous sample, but with different embedded resource files. In addition, a backdoor named /bin/snort was found, which communicates with a remote C2 server to execute commands. Analysis of network activity revealed similar domain names resolving to Windows hosts. In addition, a backdoor similar to /bin/snort and /usr/bin/javad was found. For each sample found, the document details its MD5, SHA1, and SHA-256 hashes, as well as the file size. In addition, some information about the behavior of the backdoor is provided, such as encrypting the configuration file, checking whether the current date matches the configuration file, etc. Finally, the document mentions a malicious Windows service DLL called NSIProvider.dll, which was a key finding during Cloud Snooper's analysis. ",train_248,
