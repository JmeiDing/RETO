MosaicRegressor: Lurking in the Shadows of UEFITechnical detailsContentsUEFI Bootkit RAR SFX droppers for the Curl-based downloaders BITS DownloadersMain thread C&C Communication BITS Transfer Loading the DLL modules BITS Downloader, extended BITS Downloader, extended, MSVC 10 version BITS Downloader, “HHDump.dll” BITS Downloader, “cryptui.sep” BITS Downloader, 64-bitCurl-based downloadersC&C communication Payload ABI Notable file properties C&C URLs Payload DLL names C&C communication delay Curl-based downloader, extended C&C communication Payload Curl downloader, “OINFO11.OCX” Rich header dump WinRAR wrapper “load.rem” Load Intermediate DLL loader “mapisp.dll” CryptoSysPrepE-mail downloader“Process” functionOLE2 Equation dropperPayload of the OLE2 dropper, “Data.dll”Launcher for the Curl downloader Winhttp-based downloaders, extendedC&C addresses and file names Modification with the “ID” field C&C addresses and file names23 30MosaicRegressor is a multi-stage and modular framework aimed at espionage and data gathering. It consists of downloaders, and occasionally multiple intermediate loaders, that are intended to fetch and execute payload on victim machines. In two known cases, the initial stage of the framework was installed in the victim’s UEFI firmware, achieving the above-OS level of persistence.UEFI BootkitWhen inspecting the compromised UEFI firmware, we noticed four components that had unusual proximity in their assigned GUID values. These were two DXE drivers and two UEFI applications. Upon closer analysis, we could conclude that those were compiled from the source code of a Hacking Team bootkit named VectorEDK, that was leaked in 2015 and is now available online.Rogue components found within the compromised UEFI firmwareFollowing is an outline of the revealed components:F5B320F7E87CC6F9D02E28350BB87DE6 (SmmInterfaceBase) DD8D3718197A10097CD72A94ED223238 (Ntfs)• SmmInterfaceBase: a DXE driver intended to deploy the bootkit itself on the system by registering a callback that willbe invoked upon an event of type EFI_EVENT_GROUP_READY_TO_BOOT. The event occurs at a point when control can be passed to the operating system’s bootloader, effectively allowing the callback to take effect before it. The callback will, in turn, load and invoke further components of the bootkit, in this case ‘SmmAccessSub’. This is equivalent to Hacking Team’s ‘rkloader’ component, and is built using its source code.• Ntfs: a driver used to parse the NTFS file system to allow reading or writing to disk.• SmmReset: a UEFI application intended to mark the execution of the bootkit. This is done by setting the value of avariable named ‘fTA’ to a hard-coded GUID. The same is done by the original Vector-EDK bootkit as part of the bootkit’s main business logic. In this case, it’s not invoked and it seems to be a residue from the open source code that was not properly leveraged by the developers.Setting of the fTA variable with a predefined GUID to mark the execution of the bootkit3• SmmAccessSub: the main bootkit component that serves as a persistent dropper for user-mode malware. It is executed by the callback registered during the execution of ‘SmmInterfaceBase’, and takes care of writing a binary embedded within it as a file named ‘IntelUpdate.exe’ to the startup directory on disk. This allows the binary to run when Windows accomplishes the boot process. This is the only proprietary component amongst the ones we inspected, which doesn’t rely on Vector-EDK code. It conducts the following actions to drop the intended file to disk: – Bootstraps pointers for SystemTable, BootServices and RuntimeServices global structures.– Tries to get a handle to the currently loaded image by invoking the HandleProtocol method with the EFI_LOADED_IMAGE_PROTOCOL_GUID argument.– If it succeeds, it attempts to find the root drive with Windows installation by enumerating all drives and checking that the ‘\Windows\System32’ directory exists. A global EFI_FILE_PROTOCOL object that corresponds to the drive will be created at this point and referenced to open any further directories or files on this drive.– If the root drive is found, it looks for a marker file named ‘setupinf.log’ under the Windows directory and proceeds onlyif it doesn’t exist. In the absence of this file, it is created.– If the creation of ‘setupinf.log’ succeeds, it goes on to check if the ‘Users’ directory exists on the same drive.– If the ‘Users’ directory exists, it writes the ‘IntelUpdate.exe’ file (embedded in the UEFI application’s binary) under the‘\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup’ directory.Code from ‘SmmAccessSub’ used to write the embedded ‘IntelUpdate.exe’ binary to the Windows startup directory4RAR SFX droppers for the Curl-based downloadersThese are several SFX droppers with decoy documents that were sent to victims by e-mail. Each contains a document and Path=%appdata% Setup=%appdata%\1.docx Setup=%appdata%\msreg.exe Path=%appdata% Setup=%appdata%\6.docx Setup=%appdata%\msreg.exe Simplified Chinese font “SimSun” but is unreadable and looks like a result of incorrect encoding.RAR SFX script: Path=%appdata% Setup=winword.exe Setup=contract.doc Path=%appdata% Setup=%appdata%\6.docx Setup=%appdata%\msreg.exe Simplified Chinese font “SimSun” but is unreadable and looks like a result of incorrect encoding.RAR SFX script: Path=%appdata% Setup=winword.exe Setup=contract.doc Path=%appdata% Setup=dwhost.exe Setup=0612.doc Path=%appdata% Setup=return.exe Setup=1206.doc Path=%appdata% Setup=dwhost.exe Setup=0927.doc Silent=1 display name “test” of type BG_JOB_TYPE_UPLOAD. It creates a mutex to ensure only one instance is being executed.10Mutex name: “FindFirstFile Message Bi”Enumerates all BITS jobs. For a job whose display name contains the substrings “first_tf” or “second_tf” and overall display name is five or six characters (this never happens since the conditions are contradictory), it cancels the job, effectively interrupting the transfer and removing temporary files. Then the module follows its business logic in a separate thread while running an empty window message loop in the startup thread.Main thread The program contains four blocks of data encrypted with a simple one-byte XOR algorithm. Three of those blocks contain URL strings and the fourth contains a unique string, “D22”.It builds an identification string following the format: %Computer name%-D22_32 or 64The 32 or 64 suffix is chosen based on system identification. The system is supposed to be 64 if the program is able to locate the file or directory named %WINDIR%\SysWOW64The program then follows into an infinite C&C communication loop. It delays for a hardcoded period of 20 minutes between each attempt.C&C Communication The module compiles a final URL string following the format: URL from the decrypted buffer/identification string/on.zIt then attempts to download the contents of that URL to the file %TEMP%\on.dat using its BITS transfer routine. The contents of the file areignored and the file is deleted immediately after transfer. This initial download is used to determine the valid C&C server. The module iterates through all three URLs hardcoded in its body and uses the first one that responds without error for further communication.In case any of the C&C servers provided a valid response, the program sends another download request for: URL of the valid C&C server/identification string/BeFileA.z The downloaded contents are then saved to: %TEMP%\BeFileA.dllIt also tries to fetch the file using the URL: URL of the valid C&C server/identification string/BeFileC.z and save it to: %TEMP%\BeFileC.dllThe file “BeFileA.dll” is downloaded only once during the duration of the program’s instance and is loaded in a separate thread. The attempts to download the file “BeFileC.dll” occur in every communication period. The file is loaded in the same thread.BITS Transfer The program creates a new BITS job. For a download job it names the job “first_tf” and for the upload tasks it uses the name “second_tf”. Other versions use slightly different strings as job names but they all start with “first” and “second” correspondingly, and are always identical to the names of the jobs that are cancelled during the startup. The job is started with the priority setting “BG_JOB_PRIORITY_FOREGROUND”. It also toggles the security options “BG_SSL_IGNORE_ CERT_CN_INVALID”, “BG_SSL_IGNORE_CERT_DATE_INVALID”, “BG_SSL_IGNORE_UNKNOWN_CA”, to accept invalid HTTPS certificates.It then waits for up to about five minutes for the BITS job to complete, also extending the wait if the actual transfer is in progress.11Loading the DLL modules The module expects the files provided by the C&C server to be PE DLLs. They are loaded normally using the LoadLibrary API function. Each DLL may have one or more exported functions named “CallA”, “CallB”, “CallC”, “CallD”, “CallE”.All exported functions are supposed to have the same ABI: cdecl calling convention, five arguments all passed by pointers. Following the execution of each function the program delays for one second and then processes the results returned in these arguments. Depending on the data returned by the exported function, the program may then download or upload arbitrary files from/to arbitrary URLs using its BITS transfer routine. Also, depending on the returned data, it may delete or leave the DLLs file on disk.Then it checks if a corresponding “dat” file exists in the %TEMP%directory. In case the file exists it uploads it to the C&C server using the BITS transfer routine, the same URL except the last component is identical to the actual filename. The different mutex name: “set instance state”.After starting the C&C communication thread, the program sets the registry value HKEY_CURRENT_USER\Software\ Microsoft\Windows\CurrentVersion\Run, value name qwinstd, to the location of its own executable. It also overwrites the value if it is not equal to the location of the executable. This ensures the program’s automatic startup. Also the program sets up a timer callback routine to be called every second. The routine looks for the file %APPDATA%\Microsoft\Internet Explorer\usk.rs. When such a file is found it acts as a kill switch: the file deleted, the BITS Jobs are cancelled and the program exits.Instead of the %TEMP% directory this version uses the directory %APPDATA%\Microsoft\Internet Explorer to store its temporary files.12System information The module creates a text file %APPDATA%\Microsoft\Internet Explorer\%Computername%.dat and fills it with system information. Note the non-ASCII symbols 0xA3 and 0xBE used in the string literals. These were replaced with a colon character (See “Language artifacts”).Host Infomation: EXE ID: %Unique ID, see table% Host Name: %Computername% Current User Name: %USERNAME% PRIVILEGE: %User privilege% OS: Windows NT %Major%.%Minor%\t%Service pack string%\t%Product type%\tSystemMetrics: %Build number for Windows 5.2%\tSuiteMask hex: %Suite mask% OS BITS: %32 or 64% Host Power ON Time: %04d-%02d-%02d %02d:%02d Power ON Time: %d Hours %2d Minutes %2d Seconds *or*Power ON Time: %2d Minutes %2d Seconds Installed Programe List 32: *the following list is the contents of registry keys from HKLM\SOFTWARE\Microsoft\Windows\ CurrentVersion\Uninstall* *%Item number%* *%Registry key last write timestamp in format %04d-%02d-%02d %02d:%02d%* *optional, when the program determines that it is running on a 64-bit OS, it disables 64/32 registry reflection and enumerates the installed program list again, generating a similar list with a header “Installed Programe List 64”*Remarks. The %User privilege% string is produced using the NetUserGetInfo API for the current user. Depending on the returned result, it can be one of the strings: “Administrator”, “User”, “Guest”, “ACCESS_DENIED”, “COMPUTER_ NAME_ERROR”, “USER_NAME_ERROR”. The %Product type% string is one of “VER_NT_SERVER”,“VER_NT_DOMAIN_ CONTROLLER”, “VER_NT_WORKSTATION”Once the report file is ready, the program creates a BITS job to upload it to the C&C server. The upload location follows the format: URL of the C&C server/%Computername%.dat The file is deleted if the upload succeeds.13Payload When finished with uploading the system information report, the program then attempts to fetch the payload from the C&C server. The business logic is similar to the one of the “BITS Downloader”, with the following differences:Files that are downloaded and executed in separate threads:FileA.dll fetched from %C&C URL%/%Computername%/FileA.zFileB.dll fetched from %C&C URL%/%Computername%/FileB.zFiles that are downloaded and executed in the current thread:FileC.dll fetched from %C&C URL%/%Computername%/FileC.zFileD.dll fetched from %C&C URL%/%Computername%/FileD.zEach DLL may have one or more exported functions named “CallA”, “CallB”, “CallC”, “CallD”, “CallE”, “CallF”, “CallG”, “CallH”, Many strings contain the sequence 0xA3, 0xBE (hexadecimal). This is an invalid sequence for a UTF8 string and the LATIN1 encoding translates these symbols to a pound sign followed by a “masculine ordinal indicator” (“£º”).Дanguage artifactsAn attempt to iterate over all available iconv symbol tables trying to convert to UTF-8 produces possible candidates that produce a more meaningful conversion for this byte sequence: CN-GB//, “ : ” # EF BC 9A CP936//, “ : ” # EF BC 9A CP949//, “ : ” # EF BC 9A CSEUCKR//, “ : ” # EF BC 9A CSGB2312//, “ : ” # EF BC 9A EUC-CN//, “ : ” # EF BC 9A EUC-KR//, “ : ” # EF BC 9A EUCCN//, “ : ” # EF BC 9A EUCKR//, “ : ” # EF BC 9A GB2312//, “ : ” # EF BC 9A GB13000//, “ : ” # EF BC 9A GB18030//, “ : ” # EF BC 9A GBK//, “ : ” # EF BC 9A ISIRI-3342//, “!:” # 21 3A ISIRI3342//, “!:” # 21 3A MS936//, “ : ” # EF BC 9A MSCP949//, “ : ” # EF BC 9A OSF0004000A//, “ : ” # EF BC 9A OSF100203B5//, “ : ” # EF BC 9A UHC//, “ : ” # EF BC 9A WINDOWS-936//, “ : ” # EF BC 9A Given the context of the string preceding the symbol and line feed symbols following it, the best match is the “FULLWIDTH empty; all the business logic is implemented in the DllMain function.The DllMain function, when executed with the reason code of DLL_PROCESS_ATTACH, checks if the filename of the host The module checks for the presence of the file %APPDATA%\Microsoft\Windows\load.rem. If the file is present it follows in a new thread: it copies it to %APPDATA%\Microsoft\Windows\SendTo\load.dll, then loads the copy as a regular DLL and calls its function exported with the name “Load”, if present. The copy is deleted if the module fails to load it as a DLL.Main thread The module enumerates and cancels BITS jobs if their names contain a substring “first job” or “second job” and the length of the name is either 9 or 10. This is an improvement over the original “BITS Downloader” that checked for a contradictory condition that never becomes true.The module creates a directory if it doesn’t exist: %APPDATA%\Microsoft\Network. Due to a bug, it will not attempt to create the directory if a file exists with the same name, failing later when the directory is required. This directory is then used to store any temporary files, instead of %TEMP% in the original “BITS Downloader”.Files that are downloaded and executed in separate threads:DFileA.dll fetched from %C&C URL%/%Computername%/DFileA.zDFileD.dll fetched from %C&C URL%/%Computername%/DFileD.zFiles that are downloaded and executed in the current thread:DFileC.dll fetched from %C&C URL%/%Computername%/DFileC.zExported function names executed from the payload DLLs: “CallA”, “CallB”, “CallC”, “CallD”, “CallE”, “CallF”, “CallG”, “CallH”, “CallI”, “CallJ”, “CallK”, “CallL”, “CallM”, “CallN”, “CallO”, “CallP”, “Final”.The signature of the function called “Final” is different from the rest: it takes 21 arguments that not only contain those of a BITS Downloader. It is very similar to “HHDump.dll”. The following description includes only the differences.The library provides one exported function with the name “RetrievePKCS7FromCA”. The DllMain function is empty and the module doesn’t have any checks for the name of the current executable.The payload is loaded in the same way as “HHDump.dll”; the only difference is an additional optional call to the function appeared in “BITS Downloader, extended”. It is worth noting that the part of the code that checks for, and cancels, the BITS job by name uses the same name lengths as the first “BITS Downloader” (5 and 6) but the correct substring literals “first” and “second”.This version does not create any mutex.C&C communication period: 15 minutesThis version uses the directory %APPDATA%\Microsoft\Internet Explorer to store its temporary files.The module creates a text file %APPDATA%\Microsoft\Internet Explorer\%Computername%.dat and writes a hardcoded string in there:LINEThe file is then uploaded to the C&C server using the same code that uploads the system information report in “BITS Downloader, extended”.The names of payloads, filenames and exported function names that are executed from the payload DLLs is identical to the communication routine.C&C communication The module downloads several files from its C&C server. The URL of the server is hardcoded and varies among the samples.It may download modules specific to either 32-bit or 64-bit target systems, using the suffix “32” or “64” correspondingly. For each DLL file the download routine enters an infinite loop and continues to the next module only when the current file has been download without errors. Each attempt is followed by a predefined delay that is different for each sample.The first file to download is the following:URL of the C&C server/msreg_32.dll or URL of the C&C server/msreg_64.dllThe file is saved to: %APPDATA%\msreg.dll.Next, the module attempts to download the files:URL of the C&C server/wrtreg_32.dll, saved to %TEMP%\wrtreg_32.dllURL of the C&C server/wrtreg_64.dll, saved to %TEMP%\wrtreg_64.dllThis library is then loaded, unloaded and deleted. The latter two libraries are downloaded and executed only if the file msreg.dll is is nnot present on disk.19Then the module continuously attempts to download another file:URL of the C&C server/%Computername%/%PayloadName.dll, saved to %APPDATA%\%PayloadName%.dll (%PayloadName% varies, see the list of names)The previous version of the file, if present, is moved to a temporary filename with the prefix %TEMP%\34F and then deleted. Every time a new such file is successfully downloaded, the module starts a new thread to execute it.Payload ABI The payload file is expected to be a regular Windows DLL. The code that interacts with the library is similar to the one used in BITS Downloader. The file is loaded using the standard LoadLibraryA API function. Then it resolves the addresses of functions exported with the names “ExpA”, “ExpB”,“ExpC”, “ExpD”, “ExpE”, “ExpF”, “ExpG”. The functions, if present, are then consequently called. Every function has to take five arguments passed on the stack by pointers.Depending on the returned values, the module can stop executing the exported functions, download files to disk or upload data produced by the function to the C&C server. The data is uploaded with HTTP POST request to the URL:URL of the C&C server/upload.phpThe POST request contains the part called “txt” as a file attachment, with its filename and contents provided by the exported function.Notable file properties The binary is statically linked with libcurl and contains the version string “libcurl/7.49.1”. According to the official Curl website, version 7.49.1 was released on May 30 2016.The language identifier of the file’s resources is set to 2052 (“zh-CN”). One of the resources is its version information communication routines are similar to those found in the “Curl-based downloader”.Mutex name: “single UI”Sets the autorun registry location: HKCU\Software\Microsoft\Windows\CurrentVersion\Run, value dsuiext=%location of the executable%.Every second the module checks for the presence of a kill switch file %APPDATA%\Microsoft\exitUI.rs and terminates if it is present.The module enters an infinite C&C communication loop with a preset delay between each attempt.C&C communication First, the module sends a test GET request using the URL of the C&C server and continues if the attempt succeeds. Then it collects system information and writes the results into a text file %APPDATA%\%Computername%.dat. The code that collects the system information is identical to the one found in the “BITS Downloader”. Then the resulting file with the system information is sent to the C&C server in a POST request to %URL of the C&C server/upload.php. The code also checks if there is a file %APPDATA%dat present on the disk and if so the file is uploaded instead.The URL of the C&C server and the unique identifier (“EXE ID”) are hardcoded in the binary and encrypted with a simple one-byte XOR operation.Payload When it has finished uploading the system information report the program then attempts to fetch the payload from the C&C server. The business logic is similar to the one for “BITS Downloader, extended”, with the following differences:Files that are downloaded and executed in separate threads:21%APPDATA%\Microsoft\WebA.dll fetched from %C&C URL%/%Computername%/WebA.z%APPDATA%\Microsoft\WebB.dll fetched from %C&C URL%/%Computername%/WebB.zFiles that are downloaded and executed in the current thread:%APPDATA%\Microsoft\WebC.dll fetched from %C&C URL%/%Computername%/WebC.zEach DLL may have one or more exported functions named “FunA”, “FunB”, “FunC”, “FunD”, “FunE”, “FunF”, “FunG”, “FunH”, “FunI”, “FunJ”. Once finished, the program may delete the DLL file depending on the returned value. Depending on the data process but also deletes the autorun registry value.Rich header dump The 66 modules compiled with Visual Studio 6 are parts of the libcurl library identical to the one used in the “Curl-based discovered along with one of the downloader samples.The library has an empty DllMain function and three exported functions with the names “CallA”, “CallB”, “CallC”. The description of these functions follows.23CallA • creates the directory %APPDATA%\Microsoft\Windows • deletes the file %APPDATA%\Microsoft\Windows\mapisp.dll and, if this fails, renames the file to %TEMP%\Hx101.tmp •returns the values that result in the BITS Downloader, fetching the file “SecondA.z” from the C&C server to %APPDATA%\Microsoft\Windows\mapisp.dllCallB • creates the directory %APPDATA%\Microsoft\Windows\SendTo • deletes the file %APPDATA%\Microsoft\Windows\SendTo\cryptui.sep and, if this fails,renames the file to•%TEMP%\Hx102.tmp returns the values that result in the BITS Downloader, fetching the file “SecondB.z” from the C&C server to %APPDATA%\Microsoft\Windows\SendTo\cryptui.sepCallC • sets an autorun registry value : HKCU\Software\Microsoft\Windows\CurrentVersion\Run,name mapisp to “rundll32.exe “%APPDATA%\Microsoft\Windows\mapisp.dll”,CryptoSysPrep• checks if the files “mapisp.dll” (called “file a”) and “cryptiu.sep” (“file b”) are present • writes a log of operations into the file %APPDATA%\Microsoft\Internet Explorer\FileOutA.dat and returns Strings written to the log depend on the results of the preceding operations: “second file successA” “file a success” or “file a error” “file b success” or “file b error” “registry set success” or “registry set error” “do move file a” or “do not move file a” “do move file b” or “do not move file b” exported function with the name “Load”.Load The function is an infinite loop. Every five minutes it checks if there is a file named %APPDATA%\Microsoft\Windows\LnkClass.dat. If the file is present, it then executes24“%APPDATA%\Microsoft\Windows\LnkClass.dat” a -hpHFG5fv(*&# -r “%APPDATA%\Microsoft\Credentials\MSI36C2.dat” %CSIDL_RECENT%Here, %CSIDL_RECENT% is the location of the “Recent documents” folder. Although the original file named LnkClass.dat was not recovered, the command line is valid for a popular archiver called WinRAR - it is a command to store the contents “CryptoSysPrep”.CryptoSysPrep The function checks for the presence of additional DLL files and loads them in separate threads:%APPDATA%\Microsoft\Windows\SendTo\cryptui.sep, called by function RetrievePKCS7FromCA%APPDATA%\Microsoft\Network\sppsvc.sep, copied to %APPDATA%\Microsoft\sppsvc.tbl, then loaded and called by function “PlugA”%APPDATA%\Microsoft\Network\subst.sep, copied to %APPDATA%\Microsoft\subst.tbl, then loaded and called by All strings related to the business logic are encrypted with a homebrew algorithm similar to RC4 with a hardcoded extended S-Box of 1024 bytes.The module checks if there is a file present at %COMMON_APPDATA%\Microsoft\Windows\user.rem. If it is present, the file is copied to %APPDATA\Microsoft\dfsadu.dll; then it is loaded and its export “MediaA” is called in a new thread.Then the function enters an infinite loop. Every 20 minutes it tries to connect to a POP3S server “pop.mail.ru”. The module uses the first of two pairs of hardcoded credentials that worked.Login (password hardcoded but not shown)Feedback e-mail addressthtgoolnc@mail.ruthbububugyhb85@mail.ruthgetmmun@mail.ruthyhujubnmtt67@mail.ruThe module attempts to download the first e-mail message from the mailbox into the %TEMP% directory using a temporary filename with the prefix “Ht”. If the download succeeds, it deletes the message via IMAPS using the same credentials.It parses the MIME format using a code that appears to be similar to a widespread open-source class CMimeMessage (the class name is included in the RTTI information too). It extracts the message’s subject and continues if it is equal to “RepeatA”, “RepeatB”, “RepeatC”, “RepeatD”. If the subject matches one of the names, the attachment from that message is saved and decrypted and then copied with a DLL extension:SubjectRepeatARepeatBRepeatCRepeatD26Temporary DLL name%TEMP%\RepairA.dll%TEMP%\RepairB.dll%TEMP%\RepairC.dll%TEMP%\RepairD.dllThe DLL file is then loaded and called by export “MediaA”. Depending on the return value of that function, the DLL file may be deleted or left on disk. Also, the module may encrypt a temporary file produced by the function, and send it as an attachment of type “application/x-msdownload” with the name “attach.dat”, to the “feedback” email address via SMTPS. The subject of the message is set to “MINE UPLOAD” and the “From” field is set to the login used to retrieve the incoming messages.OLE2 Equation dropperMD5: 33F21AC73AFF4DFF71316795282A3D06 (OLE2 part)This is a recovered part of a weaponized document. Since most related code and documents described in public reports are known to be RTF documents, this one could also have been embedded in an RTF document.The OLE2 stream creation date for all the streams is 2019-02-02. It contains composite objects of types “Microsoft Equation 3.0” and “Microsoft OLE 1.0 Native”. The Equation object uses a well-known exploit CVE-2018-0802 and the OLE 1.0 holds the EXE file that is decrypted by the shellcode of the exploit.Several notable findings:The OLE 1.0 Native CompObj stream contains the name in Russian “Пакет” along with the English name “Package”. It also has starts the executable from its DllMain function and returns.Winhttp-based downloaders, extendedThese samples seem to be based on the same code for collecting system information as the downloaders using BITS and Curl and use the same text messages with non-ASCII symbols. However the code in these files uses WinHTTP API for value Media=%location of the executable%.The program collects system information in a text file %APPDATA%%Computername%. The data is similar to the one collected by other “extended downloaders”, but also includes the list of running processes (all samples except mounted disks and the listings of their root directories. The text file is uploaded to the C&C server with a POST request to %C&C server%/upload.php.The module downloads two executable files. The first file is saved in the %STARTUP% folder and the second one is saved in the folder named %APPDATA%\Microsoft and started immediately. The URLs and names of the files vary. The code also contains references to the file “repeat” but that file is never downloaded. Existing files, if they are present and are different in size, are moved into a temporary file with the prefix %TEMP%\341 and then deleted.Each file is downloaded from the URL constructed according to the format: %C&C server%/%Computername%/%filename%, Agent string or “Mozilla/4.0”.C&C addresses and file namesMD5C&C serverRemote reports a unique hardcoded “ID” similar to the “EXE ID” string used in other types of downloaders. the sample 