Introduction As an object of study, targeted cyberattacks on large enterprises and government institutions are of great interest to information security specialists. The study of such incidents makes it possible to analyze the strategy and tools used by hackers to break into computer systems, and in turn develop appropriate counteraction measures. The software used in targeted attacks is usually unique since it is developed in-line with the goals and objectives of the attackers, and is not publicly advertised. In comparison with common threats, samples of such malware rarely become the object of research. In addition, targeted attacks use complex mechanisms to hide traces of malicious activity, making it more difficult to detect unauthorized presence inside the attacked organization’s infrastructure. In March 2019, Doctor Web was contacted by a client from a state institution of the Republic of Kazakhstan regarding malware presence on one of the corporate network computers. This case prompted the beginning of an investigation, resulting in the company's specialists discovering and being the first to describe the family of trojan programs used for a full-scale targeted attack on the institution. The materials we had made it possible to learn more about the tools and goals of cybercriminals who infiltrated the internal computer network. The investigation revealed that the facility’s computer network has been compromised since at least December 2017. In addition, in February 2020 Doctor Web was contacted by representatives of the state institution of the Kyrgyz Republic regarding a similar matter — signs of an infected corporate network. Our expertise has confirmed the range of malicious programs operating within the network. Some modifications of this malware were also used during the attack on the organization in Kazakhstan. Our analysis showed, as in the previous case, the initial infection began long before the enquiry — in March 2017. Because the unauthorized presence in both infrastructures continued for at least three years, as well as the event logs from servers revealing completely different trojan families, we assume that not one, but several hacker groups are likely behind these attacks. With that, some of the trojans used in these attacks are well-known: part of them are exclusive tools of certain APT groups, while the other part is used by various APT groups of China. General Information About the Attack and Tools We were able to study in detail the information from several network servers of the effected institutions in Kazakhstan and Kyrgyzstan. All devices covered in the study run Microsoft Windows operating systems. Malware used in the targeted attack can be divided into two categories: 1. Common ones installed on most network computers; 2. Specialized ones installed on servers of special interest to the attacker. The analyzed malware samples and utilities used by attackers allow us to assume the following attack scenario. After successfully exploiting the vulnerabilities and gaining access to the network computer, hackers uploaded one of the BackDoor.PlugX modifications to it. The trojan's payload modules allowed attackers to remotely control an infected computer and use it for lateral movement. Another trojan, presumably used for initial infection, was BackDoor.Whitebird.1. This backdoor was designed to operate in 64-bit operating systems and had a universal functionality: supporting an encrypted connection to the C&C server, as well as the file manager, proxy, and for remote control via the command shell functionality. After achieving a network presence, attackers used specialized malware to carry out their tasks. This is how specialized trojan programs are distributed among infected devices. Domain controller #1 Trojan.Misics Trojan.XPath Domain controller #2 Trojan.Misics Trojan.Mirage Domain controller #3 BackDoor.Mikroceen BackDoor.Logtu Server #1 BackDoor.Mikroceen Server #2 Trojan.Mirage BackDoor.CmdUdp.1 The most interesting finding is the XPath family, whose modifications, according to our information, have not been publicly described before. The family has a rootkit for hiding network activity and traces of presence in a compromised system, which was detected by the Dr.Web anti-rootkit installed on the attacked server. The samples we studied were compiled between 2017-2018. With that, these malicious programs are based on open source projects released several years earlier. Thus, the studied samples used versions of the WinDivert package released between 2013-2015. This indirectly indicates the first XPath modifications may also have been developed during this period. XPath is a module trojan, each component of which corresponds to a specific stage of malware operation. The infection process begins with the installer operation, detected as Trojan.XPath.1. The installer uses an encrypted configuration hardcoded in its body and launches the payload either by driver installation or by utilizing COM Hijacking. The program uses the system registry to store its modules, using both encryption and data compression. Trojan.XPath.2 is a driver and hides malicious activity in a compromised system by running another module simultaneously. The driver has Chinese digital signatures. Its operation is based on open source projects. Unlike other components stored in the system registry, the driver files are located on a disk, and the malicious program runs covertly. In addition to hiding the driver file on the disk, the component is also designed for injecting the payload’s loader in the lsass.exe process, as well as concealing the trojan's network activity. The operating scenario varies depending on the operating system version. PayloadDll.c is the original name for the third component. A library detected as Trojan.XPath.3 is an intermediate module that injects the payload, saved in the system registry, into the svhost.exe process by utilizing COM Hijacking. The main functionality is contained in the payload module detected as Trojan.XPath.4. The component is written in C++, and is also based on open source projects. Similar to most of the malware analyzed in this study, this trojan is designed to gain unauthorized access to infected computers and steal confidential data. Its key feature is the ability to operate in two modes. The first is the Client Mode. In this mode, the trojan connects to the C&C server and waits for incoming commands. The second is the Agent Mode. In this mode, Trojan.XPath.4 carries server functions: it listens for certain ports, waits for other clients to connect to them, and sends commands to these clients. Thus, the malware creators have provided the possibility for deploying a local C&C server inside the attacked network to redirect commands from an external C&C server to infected computers inside the network. For a detailed description of the XPath family and how it works, see Operating Routine of Discovered Malware Samples. Another interesting finding is the Trojan.Mirage access implementation to the command shell. To perform command shell I/O redirections, the malware used files that we were able to retrieve from an infected server during the investigation. With them we managed to see the commands executed by cybercriminals using the following trojan function, as well as the data received in response: reg add HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\Wdigest /v UseLogonCredential /t REG_DWORD /d 1 /f ipconfig /displaydns HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\Wdigest The launched windbg.exe file was a TCP/UPD port scanner utility called PortQry. During our investigation, we found evidence indirectly confirming the connection of targeted attacks on institutions of Central Asian republics. One of the uncovered samples called BackDoor.PlugX.38 used the nicodonald[.]accesscam[.]org domain, which was also used as the C&C server for BackDoor.Apper.14, also known as ICEFOG NG. A few years ago, we discovered a backdoor of this family in a phishing email sent to one of the state institutions in Kazakhstan. Also, an RTF document that installs this sample of BackDoor.Apper.14 was first uploaded to VirusTotal from Kazakhstan on March 19, 2019. An interesting finding within the framework of the Kyrgyzstan incident is the Logtu backdoor found on an infected server along with the Mikroceen backdoor. In addition to a similar set of malware used by attackers in both incidents, Mikroceen points to a possible connection between the two attacks: a sample of this highly specialized backdoor was found on both networks and in both cases it was installed on the domain controller. During the search for samples related to these attacks, we found a specially made backdoor that implements BIND Shell access to the command shell. The program’s debugging information contains the project name in Chinese, , which may indicate the trojan’s origin. In addition to malicious programs, attackers used the following publicly available utilities for lateral movement within the network: · Mimikatz · TCP Port Scanner V1.2 By WinEggDrop · ZXPortMap v1.0 By LZX · Earthworm · PortQry version 2.0 GOLD Examples of launching some of the listed utilities are shown below. The APT group also actively used its own PowerShell scripts to perform various tasks, such as collecting information about an infected computer and other network devices, checking the C&C server status from an infected computer, etc. In addition, we found a PowerShell script designed for downloading all the contents from the Microsoft Exchange Server mailboxes of several of the organization’s employees. Examples of certain PowerShell scripts executed on infected servers: powershell -nop -enc powershell.exe -executionpolicy bypass -WindowStyle Hidden -File C:\programdata\x.ps1 %COMSPEC% /Q /c tasklist /v >>c:\programdata\2.txt %COMSPEC% /Q /c systeminfo >>c:\programdata\2.txt %COMSPEC% /Q /c netstat -nvb >> c:\programdata\2.txt powershell -exec bypass -command "& { foreach($i in 53,80,443){ echo ((new-object Net.Sockets.TcpClient).Connect('v.nnncity.xyz',$i)) "port:"$i } 2 > $null }" >>c: \programdata\2.txt Operating Routine of Discovered Malware Samples Trojan.XPath.1 Trojan.XPath.1 is an installer for the multi-functional XPath backdoor. It operates on both 32- bit and 64-bit Microsoft Windows operating systems. The payload is extracted by installing the driver or by utilizing COM Hijacking. Operating routine Using the 5-byte magic number, the installer checks whether the configuration embedded in it has encryption. The configuration is then used for the payload functioning. If there is no encryption, the program shuts down. After that, the malware receives information about the OS version, UAC settings and checks whether the user has administrative privileges. A string is formed from obtained data: admin:%d,dwCPBA:%d,dwLUA:%d,om:%d-%d Then, the program outputs it via the OutputDebugStringA function. Next, the trojan attempts to install its driver. In case of failure, an attempt is made to install the module using COM Hijacking. After that, the program deletes its file from the disk and terminates its process. Driver installation It deletes the yyyyyyyyGoogle.sys file from the %WINDIR%\\tracing\\ directory. It extracts the desired driver version from its body, depending on the system architecture bit widths, and saves it to the specified path. Drivers are stored in the sample being compressed via the APLib library and are additionally encrypted by an algorithm based on the XOR operation with a single-byte key. It then stores its payload in the registry as three modules. It uses [HKLM\\SOFTWARE\ \Microsoft\\LoginInfo] as its working registry branch. It creates keys in it and saves the payload there: · Video — configuration; · DirectShow — XPath module; · DirectDraw — PayloadDll module. The modules are hardcoded in the trojan’s body in a similar form to the driver (using APLib and XOR) and are present in two versions — for both 32-bit and 64-bit systems. Each module uses its own single-byte key. The modules are saved as a structure: #pragma pack(push,1) _BYTE data[compressed_size]; }; #pragma pack(pop) The data module is decoded, but remains compressed. The program then attempts to create a service with autorun and ImagePath to the extracted driver. The driver file name is used as the service name. If the service cannot be launched via SCManager and the service has already been created, an attempt is made to start the driver via ZwLoadDriver. To check if the driver is working, the malware attempts to open the \\.\BaiduHips device. In case of failure, a second attempt is made after 100 milliseconds. A total of 15 attempts are made, after which the driver installation is considered incomplete. If the driver is running, it sequentially starts the [%WINDIR%\\System32\\ping.exe], [%WINDIR%\\System32\\rundll32.exe %WINDIR%\\System32\\svchost.exe] and [%WINDIR%\\System32\\lsass.exe] processes. COM Hijacking The program saves its modules in the registry the same way as when installing the driver, but this time using [HKCU\\SOFTWARE\\Microsoft\\LoginInfo] as the home branch. It iterates through the registry keys in the HKU section and searches for a key with a name containing the S-1-5-21- substring and does not contain the _Classes substring. Inside this key, it creates the Software\\Classes\\CLSID\\{ECD4FC4D-521C-11D0-B792- 00A0C90312E1}\\ key for Windows 2000, Windows XP, Windows Server 2003, and the Software\\Classes\\CLSID\\{B12AE898-D056-4378-A844-6D393FE37956}\\ key for Windows Vista or later. For this key it sets the %TMP%\\Microsoft\ \ReplaceDll.dll path as the parameter value (by default). It also creates the ThreadingModel parameter with the Apartment value. After that, it unpacks the PayloadDll module into the %TMP%\\Microsoft\ \ReplaceDll.dll directory. The Trojan.XPath.1 file contains leftover debugging information that reveals the paths and source code file names: z:\\desk_codes\\project_xpath\\xpathinstaller\\client_files.h z:\\desk_codes\\project_xpath\\xpathinstaller\\MemLoadDll.h xPathInstaller.c The original function names are: The file also contains various debugging messages: start TRUE:%s,%d\n pOpenSCManager false:%s,%d\n ZwLoadDriver false1 :%s,%d,%d\n ZwLoadDriver false2 :%s,%d,%d\n ZwLoadDriver false3 :%s,%d,%d\n ZwLoadDriver false1 :%x\n ZwLoadDriver ok : %x\n ZwLoadDriver false: %x type:%d\n install all failed\n can not pCreateFile,inst failed :%s,%d\n %s,%d,%d\n admin:%d,dwCPBA:%d,dwLUA:%d,om:%d-%d The setinfo false string is the most interesting. It contains the 0xACA3 sybmol, which in Unicode corresponds to the hieroglyph. This hieroglyph is used in South and North Korean writing. Trojan.XPath.2 Trojan.XPath.2 is a driver for the multi-function XPath backdoor. It has two versions for both 32-bit and 64-bit Microsoft Windows operating systems. The component is designed to inject the payload loader into the lsass.exe process, as well as for traffic filtering. Operating routine Trojan.XPath.1 serves as a loader for the driver. Operating in Windows starting from Vista or higher is based on the source code of the WinDivert 1.1 (30.06.2013) - 1.2 (17.07.2015). Operating in Windows starting from Windows 2000 up to Vista is based on the source code of the WinPcap. Drivers have the following digital signatures: CN = Anhua Xinda (Beijing) Technology Co., Ltd. OU = Digital ID Class 3 - Microsoft Software Validation v2 O = Anhua Xinda (Beijing) Technology Co., Ltd. The trojan obtains the addresses of the necessary functions from a NDIS.SYS file: It then checks which of the available modules — hal.dll, halmacpi.dll or halacpi.dll — was loaded, and gets the addresses of several functions from it: Next, it checks if the ntdll.dll module is loaded. If it is not loaded, Trojan.XPath.2 independently maps the file into the memory, and gets the addresses of the necessary functions: Then trojan creates the device \\Device\\test1 and the symbolic link \ \DosDevices\\test1. Via PsSetCreateProcessNotifyRoutine it sets a callback function in which it tracks the lsass.exe process creation. As soon as this process is started, the trojan reads the loader module (Trojan.XPath.3) from the registry [\\registry\\machine\\SOFTWARE\ \Microsoft\\LoginInfo] 'DirectDraw'. Then it unpacks it and injects it into the lsass.exe. In the 64-bit version of the driver, code is injected via the PsSetLoadImageNotifyRoutine function. The program waits until it can open \\Systemroot\\explorer.exe, then via IoCreateDriver it creates the \\FileSystem\\FsBaiduHips driver. It records the following values in the registry: · [\\Registry\\Machine\\System\\CurrentControlSet\\Services\ \yyyyyyyyGoogle] 'Group' = "Boot Bus Extender"; · [\\Registry\\Machine\\System\\CurrentControlSet\\Services\ \yyyyyyyyGoogle] 'DependOnService' = "FltMgr"; · [\\Registry\\Machine\\System\\CurrentControlSet\\Services\ \yyyyyyyyGoogle\\Instances] 'DefaultInstance' = 'yyyyyyyyGoogle Instance'; · [\\Registry\\Machine\\System\\CurrentControlSet\\Services\ \yyyyyyyyGoogle\\Instances\\yyyyyyyyGoogle Instance] 'Altitude' = '399999'; · [\\Registry\\Machine\\System\\CurrentControlSet\\Services\ \yyyyyyyyGoogle\\Instances\\yyyyyyyyGoogle Instance] 'Flags' = '00000000'. Then it attempts to register as a minifilter. If the FltRegisterFilter function returns the STATUS_FLT_INSTANCE_ALTITUDE_COLLISION error, the program reduces the value of Altitude by one, and then retries. When registering as the minifilter, the PreOperation callback function is set for IRP_MJ_CREATE: For IRP_MJ_QUERY_INFORMATION a callback function is set: For IRP_MJ_DIRECTORY_CONTROL, both the PreOperation and PostOperation callback functions are set. These four functions are used to conceal the driver file. The trojan then creates the device \\Device\\BaiduHips and the symbolic link \ \DosDevices\\BaiduHips. Further behavior depends on the infected computer’s OS version. BaiduHips (Windows 2000, Windows XP, Windows Server 2003) The program registers the BaiduHips NDIS protocol. To perform the firewall functionality, the driver intercepts the SendHandler, ReceiveHandler, ReceivePacketHandler, and OpenAdapterCompleteHandler functions: Hooks are inserted only after receiving the IOCTL code 0x80000800. After that, the program starts filtering traffic (see below). BaiduHips (Windows Vista, Windows Server 2008 or higher) It creates a WDF driver, and passes [\\Registry\\Machine\\System\ \CurrentControlSet\\Services\\BaiduHips] as the service path. Further initialization is similar to the standard initialization of the WinDivert driver. The trojan tracks traffic transmitted over IPv4. The most important difference from the standard WinDivert is the windivert_filter function, which filters packets (see below). Firewall The second (in addition to payload launch) main function of the driver is to filter traffic. The firewall filters TCP/UDP packets transmitted over IPv4. The rules are defined as structures: #pragma pack(push, 1) _BYTE src_mac[6]; _BYTE dst_mac[6]; #pragma pack(pop) The src_mac, dst_mac, ack, and sn fields are optional. It should be noted that depending on the packet direction, the fields are compared accordingly. In other words, to transmit a packet in both directions between two devices, a single rule is sufficient, where the recipient is the computer that runs this rootkit. There are two ways to add firewall rules: 1. Via the corresponding IOCTL code, 2. By sending specially generated packets over the TCP Protocol. Special packet 1 This is a TCP packet with the following parameters: · The AckNum value is set to 0x87ED5409; · The SeqNum value is set to 0x1243FDEC; · RST flag is set. When such a packet is received, a rule is added to the firewall that allows traffic to pass from the sender's IP address and the src_port + 1 port to the specified destination and in the opposite direction. Special packet 2 This TCP packet size must be 32 bytes. The first 4 bytes are the key for decrypting the rest of the data. Decryption function: Next, bytes from 4 up to 12 are compared with the 1I2#aLeb string. If a match occurs, a rule is added to the firewall that allows traffic flow from the sender's IP address and port. It is worth noting that the TCP Handshake process is not performed and flags are ignored. Only the size of the data and the data itself matter. IOCTL codes The trojan’s IOCTL codes: · 0x80000800 — to insert hooks on network functions (only available on Windows versions up to Windows Vista) · 0x80000815 — to add a firewall rule for the TCP Protocol; · 0x80000819 — to delete a firewall rule for the TCP Protocol; · 0x8000081D — to add a firewall rule for the UDP Protocol; · 0x80000821 — to delete a firewall rule for the UDP Protocol; · 0x80001005 — to set the value of two variables (not used). IOCTL codes from WinDivert (available only for OS versions starting from Vista and higher): · 0x80002422 — to receive a diverted packet; · 0x80002425 — to send a packet; · 0x80002429 — to start filtering; · 0x8000242D — to set the level; · 0x80002431 — to set the priority; · 0x80002435 — to set the flags; · 0x80002439 — to set the parameter; · 0x8000243E — to receive the parameter’s value. Artifacts In addition to project files path disclosed in PDB: Z:\desk_codes\project_xpath\ObjFile\SecKernel\SecKernel.pdb Z:\desk_codes\project_xpath\ObjFile\SecKernel64\SecKernel.pdb The code contains the names of specific files with the trojan’s source codes: There are also various debugging messages: out of memory2 out of memory3 out of memory4 del tcp pid:%d,%d,%d\n size not match:%d,%d\n get:%wZ mac:%02x-%02x-%02x-%02x-%02x-%02x test my tcp packet,eth len:%d,%d-->%d\n init drv :%d,%d\n init drv :%x\n \C:\InjectIntoProcess crash \C:\NewProcess crash \C:\ProcessGone crash \C:\ProcessCallback crash \C:\InitDriver crash Trojan.XPath.3 A trojan library written in C and designed to run on the 32-bit and 64-bit Microsoft Windows operating systems. It represents one of the components of the Trojan.XPath trojan family and is installed by the Trojan.XPath.1 onto the target system. The main function of this library is to inject the payload, saved in the registry, into the svhost.exe process. Operating routine Trojan.XPath.3 has the following system exports: The trojan receives all the necessary imports through the WinAPI LoadLibraryA/GetProcAddress, while the names of the required functions in its code are not encrypted. If the trojan runs in the context of the explorer.exe, it checks for the version of the OS where it is launched. For the operating systems below Windows Vista, Trojan.XPath.3 receives function exports from the themeui.dll: For the operating systems starting from Windows Vista and higher, it receives function exports from the ExplorerFrame.dll: The trojan requires these function addresses in order to call the corresponding functions whenever a trojan library export of the same name is called. Using the Global\\RunThreadOfWinDDK8O98 mutex, Trojan.XPath.3 verifies only one instance of it is running. Using ZwQuerySystemInformation, the trojan counts the number of processes running in the system. It waits until their number exceeds 7, then starts the %WINDIR%\\system32\ \svchost.exe process with the CREATE_SUSPENDED flag. Trojan.XPath.3 reads the DirectShow parameter from the registry thread [HKLM\ \SOFTWARE\\Microsoft\\LoginInfo] or [HKCU\\SOFTWARE\\Microsoft\ \LoginInfo] where the payload is stored. It then unpacks the payload using the APLib Next, the trojan allocates a memory block of 0xC80F0 bytes. At the beginning of the block it forms the following structure: #pragma pack(push,1) char char0[128]; _BYTE payload[payload_size]; }; #pragma pack(pop) Herewith, in the analyzed sample the char0 value represents a asdsad11111222333 constant. The trojan allocates a memory block of the size of 0xD80F0 bytes to the previously launched svchost.exe process and copies the entire region of 0xC80F0 bytes onto it. Next, Trojan.XPath.3 searches for the 0x12345688 constant, which is located in the shellcode built into it and replaces it with the memory block address, previously allocated in the svchost.exe process. It then copies this shellcode onto the allocated block using the 0xC90F0 offset. For systems below Windows 8, the trojan receives CONTEXT of the thread in the svchost.exe process and patches the RIP/EIP register with the shellcode, adding 8 bytes to it. For more recent OS versions, Trojan.XPath.3 launches the thread through NtCreateThreadEx. Artifacts Traces of the debug information inside the trojan library allow finding the name of the trojan’s source code file: PayloadDll.c. Various debugging messages, which are stored in the library: os ver:%d,%d,%d payload_%04d-%02d-%02d_%02d-%02d-%02d.dmp get target api address false\n depack get packed size error:%d\n depack false\n Alloc Mem in target process false!!!\n writing info to target process false!!!,%d,%d,%x get magic false\n writing stub to same architecture process:%p\n writing payload to target process false!!!,%d GetProcessEntryPoint is:%x\n !OpenProcessToken,%d\n !DuplicateTokenEx,%d\n get TokenInformation,%d\n !SetTokenInformation,%d\n !pCreateEnvironmentBlock,%d\n !xOpenProcess \n loader path:%s\n Creaet Process All Failed ERROR=%d\n try gen info\n gen info ok\n WritePayloadToRemote false\n write info ok\n error thread GetThreadContext Error\n GetThreadContext eip:%p\n set thread context error\n SetThreadContext eip:%p\n create thread ok\n get func error in payload\n get lib error in payload\n try runthread in payload\n in payload\n Trojan.XPath.4 A multifunctional backdoor trojan for the 32-bit and 64-bit versions of the Microsoft Windows operating systems. It is one of the components of the Trojan.XPath trojan family. It is used for granting unauthorized access to infected computers and performing various malicious actions upon attackers’ commands. Trojan.XPath.4 is written in C++ and created using several open source projects. One of them is the Cyclone TCP library designed for low-level operation within the network. Malware creators modified it to use the WinDivert driver instead of the WinPcap driver. The second project is the modified libdsm library, which implements the operation through the SMB The trojan reads and decrypts the configuration file from the Video or Scsi parameter stored in the [HKLM\\SOFTWARE\\Microsoft\\LoginInfo] registry key. It then verifies if the first 4 bytes coincide with the 1E 5A CF 24 value and if the 16th bite equals 0xCE. Next, Trojan.XPath.4 forms a unique HWID (Hardware ID) identifier of the infected device, based on its hardware configuration. After that, it opens the device \\.\BainduHips to verify the network driver is available. Depending on the operating system version, any calls to the driver are performed in a specific way. The first one is executed in the Windows operating system versions, starting from Windows 2000 and ending with Windows Server 2003 R2 where the WinCap-based driver is used. The second one is executed on newer versions of Windows where the WinDivert-based driver is used. In order to determine through which network interfaces the trojan should work, it searches for the network interfaces with types MIB_IF_TYPE_ETHERNET and IF_TYPE_IEEE80211, which are connected to the network. If Trojan.XPath.4 is running on a Windows version earlier than Windows Vista, it sends the IOCTL code 0x80000800 to its driver. After this IOCTL code is received, the driver installs its own hooks onto the handlers, which are responsible for various functions of the TCP/IP protocol. Based on that, the trojan can operate in two modes. In the first mode, it functions as a client (Client Mode), connecting to the C&C server and waiting for the corresponding commands. In the second mode, the trojan operates as an agent (Agent Mode), listening to the specific ports, and waiting for other clients to connect and receive their corresponding commands. In this mode, Trojan.XPath.4 acts as a server. Operation in the Agent (Server) Mode While working with the network driver, Trojan.XPath.4 does not actually listen to or receive connections on a port. Instead, the driver listens for traffic on the network interface and sends filtered packets to the trojan. As a result, the port, to which the trojan listens, is not shown as opened anywhere. Trojan.XPath.4 checks the current day of the week and the time set in the system settings and compares their values with the data from the configuration file. In this file, there is flag for each hour of each day of the week, which inform the trojan if it should run at that specific time. If there is no flag for the current time, the malware will not receive any packets. Trojan.XPath.4 waits for an incoming packet of 32 bytes. Next, it takes the first 4 bytes as an XOR key to decrypt the remaining 28 bytes. The decryption algorithm is shown in the picture After decryption, it verifies bytes 4 through 12 and does not perform any further actions if these bytes match the string 1I2#aLeb. If this string is not present, the trojan attempts to decrypt the packet with the AES key instead of the XOR key. Next, the trojan verifies if the first 4 decrypted bytes match the string 7r#K. If there is no match, the trojan will determine an error has occurred, and all further packet processing will be stopped. But in case there is a match after decryption, this packet will have the following structure: #pragma pack(push,1) _BYTE com_flag[4]; _BYTE pad[16]; }; #pragma pack(pop) If the packed_size field has 32 value, and the decomp_size field has the value of 0, the trojan verifies if there is a tunnel to another bot created. If the tunnel exists, Trojan.XPath.4 redirects the command into it, so that the connected bot can execute it. If there is no tunnel, the trojan executes the command itself. If the values of the field mentioned earlier are different from those the trojan expects, it will round off the size of the packed_size field to the larger value, multiple to 16, which represents the size of packet’s payload. After that, it receives the rest of the data, decrypts it with one of two AES keys and unpacks it with the LZMA algorithm. Next, it verifies if the size of the unpacked data matches the size presented in the decomp_size field of the st_packet_header packet. If the site match is confirmed, Trojan.XPath.4 sends the received command into the tunnel or executes it on its own if the tunnel was not created. Operation in the Client Mode The trojan will run in this mode if the configuration file contains the C&C server address and the operation mode 3, which corresponds to the Client Mode, is specified. The malware sample analyzed has a 4 mode specified, which corresponds to the Agent Mode. The trojan generates a random port number within the range of 65530 and connects to it. Next, it forms the following packet: #pragma pack(push,1) _BYTE magic[8]; // "1I2#aLeb _DWORD packet_id; // 0x00 _DWORD dword14; // 0x00 _WORD port; _BYTE byte16[10]; }; #pragma pack(pop) In the port field it specifies the number of the previously generated port. Next, it takes the GetTickCount() value as an XOR key to decrypt the packet, and encrypts this value in its first 4 bytes. The trojan creates the socket, connects to the C&C server listed in the configuration file, sends the packet, and ends the connection. Upon receipt of this packet, the trojan driver will add IP:port from where the packet originates into the firewall exceptions. Next, Trojan.XPath.4 connects to the same C&C server again, but this time, it uses the socket to which it was earlier connected through the random port. After that, Trojan.XPath.4 sends the packet TOKEN_CLIENT_LOGIN to the C&C server and waits for further commands (additional information about the commands is listed in the corresponding table of the Commands list section of this description). Reception and dispatch of the packets is executed in the same way as with the operation as a server (Agent (Server) Mode). If the packet has any data, that data is packed with the LZMA algorithm. As a result, the following data structure is created: · The header in a form of the st_packet_header structure (this structure is described in the “Operation in the Agent (Server) Mode” section): #pragma pack(push,1) _BYTE com_flag[4]; _BYTE pad[16]; }; #pragma pack(pop) · Compressed data The resulting data, together with the header, is compressed with the first AES key and sent to the addressee. The only packet not compressed and encrypted with the AES key is the Commands IDs Name of the command Resulting action Confirms the Agent-server operation 0x138D Allocates additional socket or execute the command stored in the packet’s data Enables additional connection with the Agent-server and executes the command Confirms the C&C server Sends the command to establish the connection with the C&C connection with the C&C server and executes the command 0x4E25 Ends the connection 0x4E26 Updates the trojan driver and the modules 0x4E27 A command for the trojan to Checks if the server is ready 0x4E2A Ends the trojan process 0x4E34 Forces the computer to shutdown 0x4E35 Forces log out from the user’s computer account 0x4E36 Forces the computer to reboot 0x4E37 Powers off the computer 0x4E38 Forces log out from the user’s computer account 0x4E39 Reboots the computer Runs the Shell Starts reading the data from the Shell 0x5016 Sends the data to the Shell Closes the Shell Launches the plug-in creating the tunnel 0x5079 Sends the data to the C&C server that has a connected 0x507A Sets the C&C server address to which the tunnel will be created Creates the tunnel to the specified C&C server 0x507C Receives NetBios name of the specified IP address Disables the tunnel Runs file manager 0x5E31 Directory listing 0x5E32 Reads the file from the specified offset 0x5E33 Creates the file 0x5E34 Writes into the file from the specified offset 0x5E36 Reads the file from the specified offset 0x5E37 Transfers an empty packet with the 0x98BC code to the C&C server 0x5E38 Deletes the specified file 0x5E39 Recursively deletes the specified directory or files 0x5E40 Obtains the file size 0x5E41 Creates the folder 0x5E42 Moves the file 0x5E43 Runs the file with the window 0x5E44 Runs the file without a window 0x5E47 Receives the data about the file (creation and modification time, access information, file size, file type, the name of the app that can be used to open this file) 0x5E49 Sets file attributes specified in the command 0x5E51 Disables the file manager 0x5E52 Recursively lists the specified Client authorization on the Set public_active flag Artifacts The trojan file contains traces of debugging information that reveals the names of the following source code files: \\common\\LzmaLib.c z:\\desk_codes\\project_xpath\\xpath\\ringqueue.h z:\\desk_codes\\project_xpath\\xpath\\untils.h z:\\desk_codes\\project_xpath\\xpath\\ShellManager.h z:\\desk_codes\\project_xpath\\xpath\\file.h z:\\desk_codes\\project_xpath\\xpath\\tunnel.h z:\\desk_codes\\project_xpath\\xpath\\network.h z:\\desk_codes\\project_xpath\\xpath\\clientmode.h xPathMain.c cyclone_tcp\\core\\bsd_socket.c The original functions names: The original commands names: Various debugging messages: get conf,agent:%d,client:%d,interval:%d,listen1:%d,addr1:%s:%d \n os init:%d-%d-%d bGetConfig:%d %d\tver:%10d\n ver:%d remote:%d listen:%d\n x_decompress bad in tcpR,socket:%d token:%d len:%d,target len:%d,%d\n dir: %ws,%ws,%ws,%d,%d,%d file: %ws,%ws,%ws,%d,%d,%d tunnel connect error :%x--%d,%d,%d\n init get ip:%s,%s,%s,%02x-%02x-%02x-%02x-%02x-%02x,%s\n ready accept port of client to agent:%d,local: %x--%d\n stack set ip:%s mask:%s gw:%s baidu_tx_web%d stack add ip:%s mask:%s gw:%s agent must with driver\n current if:%d\n the connect thread is ending \n the sub connect thread is ending \n listen thread1 out\n client unknown token %d\n errorrrrrrrrrrrrrrrrrr:%d,%d,%d\n tcp reverse decrypt error\n tcp reverse com flag error\n %04d %02d %02d-%02d:%02d:%02d : update alloc memory false\n update depack false,%d,%d,%d\n create update driver error\n alloc driver memory error,%d\n depack driver error\n write driver error\n client type wrong:%d,%d,%d BackDoor.Mikroceen.11 BackDoor.Mikroceen.11 is a backdoor written in C++ and designed for 64-bit versions of the Microsoft Windows operating systems. Upon installing, it connects to the C&C server directly or using the proxy server and begins executing attackers’ commands. It can collect information about the infected computer and execute commands, redirecting the output of the command shell to the control server. In both investigated campaigns, it has been installed on the domain controller. Operating routine The backdoor file represents a dynamic library with the single NwsapServiceMain export function. The sample in question was installed on the system as a service and located in the c:\windows\system32\nwsapagent.dll directory. During the operation, it maintains an event log, which is stored in the %TEMP%\ \WZ9Jan10.TMP file. The messages in this log are obfuscated, and their possible variants are shown below: · WvSa6a7i —launch of the trojan; · Dfi1r5eJ — direct connection to the C&C server; · PVrVoGx0 — connection to C&C server through previously defined proxy server; · Q29uUHJv — connection error; · 10RDu6mf — proxy server connection error; · 8sQqvdeX:%d — an error receiving the data from the C&C server; · Lw3s1gMZ — proxy server connection error; · IsEArF1k — successful connection; · CcFMGQb8 %s:%d — connection to the proxy server, recorded in the netlogon.cfg; · RWehGde0 %s:%d — connection to the proxy server, received through the WZ9Jan10.TMP file parsing; · PV2arRyn %s:%d — connection to the proxy server, found through the tcptable; · W560rQz5 — SSL connection establishing. All the relevant data, such as the C&C server address, is encrypted with a simple addition operation of the value with each byte of the string. The decrypting fragment is shown below: for ( i = 0; i < lstrlenA(v4); ++i ) v4[i] += 32 - i; BackDoor.Mikroceen.11 tries to directly connect to the C&C server. If failed, it tries to connect through the proxy server. The connection is established when the trojan knows the proxy server address. Otherwise, it reads the %WINDIR%\\debug\\netlogon.cfg file, which must contain the IP:port line. If the netlogon.cfg file is missing, or the trojan failed to connect to the address listed in it, the trojan reads the line from its own log file and parses IP:port from it. If there is no connection, the trojan parses information about current connections and searches the connection with the MIB_TCP_STATE_ESTAB status and the following ports of the remote host: 80, 8080, 3128, 9080. Among the selected connections, it searches After successfully connecting, the trojan collects information about the infected system and fills the following structure: #pragma pack(push, 1) _DWORD dword30001; // 30001 char id[16]; // "wsx" char ip[16]; char hostname[32]; }; #pragma pack(pop) BackDoor.Mikroceen.11 sends this information to the C&C server and waits for the reply. When exchanging commands, the text protocol is used, and the names of the commands are obfuscated. The list of commands is shown in the table below. The command An argument The description The reply Reads the file First QWORD is the file size; next goes the file that was read with the 1024 bytes blocks Ki0Swb7I Gets information about logical disks A structure with the information about the disks, but not larger than 1024 bytes. #pragma pack(push, char cmdid[9]; // The command An argument The description The reply #pragma pack(pop) J8AoctiB string — is a command; string — is a path to the file to read; string — is a path to the file to write Launches the file QWORD — is a file size; BYTE[]— is the data to be written into the file Writes to the file QWORD — the file size if the latter already exists h71RBG8X string — is a command Executes the command within the command shell; exit — closes the string — is a path to the file Runs a file with CreateProcessA 4FJTUaUX if successful KbZ5piK8 if failed eYTS5IwW Ends the command shell process bo7aO8Nb (if command shell was not launched) AmbZDkEx string — is a password The beginning of the exchange kjoM4yJg (if the argument matches the line encoded into the file ("12345") Mf7VLAnr (in all other Launches a command shell, redirecting the output to the server BackDoor.Logtu.1 A multifunctional backdoor trojan for 32-bit and 64-bit Microsoft Windows operating systems. It represents an executable library written in C++. It uses vector classes and strings from the STL library (Standard Template Library). The main function of the trojan is to obtain unauthorized access to infected computers and perform malicious actions at attackers’ The library contains the following exporting functions: The mymain carries the main functionality of the trojan. mymain function When called, this function uses GetTempFileNameW to generate the name of the temporary file with the .rar prefix and opens it for writing. This file is used as a journal. Writing to the journal is performed in the following format: [%d-%02d-%02d %02d:%02d:%02d] %d %d\n%s\n\n" => "[YYYY-MM-DD HH:MM:SS] <rec_id> <error_code>\n<record>\n\n where: · rec_id — is a record type ID; · error_code — error code (in most cases, it has a 0 value); if an error occurs during execution, the GetLastError() or WSAGetLastError() value is written; · record — additional data. Before it is added to the journal, the written data is encoded with the XOR operation, using the 0x31 byte. The rec_id table of ID values is listed at the end of this description. Next, the trojan collects the following information about the infected system: WCHAR str_test[8]; //возможно ID DWORD dword_1; BYTE user_name[64]; BYTE gap_0[64]; WCHAR host_IP[20]; WCHAR host_name[15]; BYTE gap_1[98]; BYTE user_SID[128]; //string SID BYTE mac_address[12]; BYTE gap_2[3]; It then checks that the library runs inside the VMWare virtual machine environment. If it detects a virtual machine, the corresponding information is added to the collected system data, while the trojan continues to run. There is a list of several C&C server addresses encoded inside the source code of the BackDoor.Logtu.1. They are encrypted with the XOR, using the 0x11 byte. However, only the first address from that list is used to control the backdoor: · 104.194.215[.]199; · 192.168.1[.]115; · www[.]test[.]com. Moreover, the trojan stores an array of ports within which each element corresponds to one of the servers above: 443, 443, 80. BackDoor.Logtu.1 has an option to use a proxy server, but the analyzed sample lacks such an address. If the proxy server address is present, it is also encoded byte by byte with the XOR operation, using the 0x11 byte. After the initial preparation, the trojan launches the cycle of connections to the C&C server through the TCP socket. Within the first connection, BackDoor.Logtu.1 tries to directly connect to the server. If it fails, it uses an HTTP proxy server if its address is encoded into the body of the trojan. If it wasn’t successful, the trojan extracts the proxy server parameters from the [HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ProxyServer] registry key and tries to establish the connection. In case of another failure, the backdoor tries to obtain the proxy server information through the WinHTTP API, sending the google[.]com request via the WinHttpGetProxyForUrl function. If this attempt has also failed, BackDoor.Logtu.1 tries to extract the corresponding settings from the HKU\<session_user_SID>\ \ProxyServer registry key. This cycle repeats until the trojan is successfully connected to the server. After successfully connecting, BackDoor.Logtu.1 sends the information about the infected system to the server. The data transfer and response receipt is divided into two stages: 1. Sending the packet with the length of the payload, 2. Sending the payload itself. The value of the packet with the length of 4 bytes equals <payload_len>+4. This is because the packet with the payload contains a 4 bytes prefix, which in turn, contains the payload ID. Consequently, the payload has the format as shown below: BYTE payload[payload_len]; } The data transferred from the trojan to the server, as well as its response, are encrypted with the RC4 algorithm. The encryption key is stored inside the trojan body as a separate string, but calculates using the following algorithm: from hashlib import md5 password = "123456" salt = md5("").hexdigest() key = md5(password + salt).hexdigest() The ID of the packet with the system information has a value of 0. After the system information is sent and the trojan receives the response from the server, it launches a thread that sends heartbeats every minute. Their ID has a value of 1 and the payload length has a value of 0. After 10 packets are sent, the server connection closes and reestablishes again. The backdoor waits for the server reply with the packet with the length value that should not exceed 0x1F40. Next, it waits for the packet itself, which contains the command as a payload. After this packet is decrypted, it checks the value of the first DWORD, which is the command ID. The ID value should not exceed 0x34. In some cases, the command contains additional parameters presented in the form of the strings split with the | symbol. The structure of this command has the form of the "param_0"|"param_1"| |"param_n". The list of commands that the trojan can receive and execute is shown in the table below. Calls GetTickCount(), writes the result into the global variable. 0x02 In this command, two parameters separated with the | symbol, are received. The first one is the path to the file. The trojan uses it to form two new paths: Next, the trojan checks if the file with the original name, specified in the command, exists. If it exists, the trojan sends the response <param_1>|01 to the server. If it does not exist, it checks if the <param_0>.tu is present. If this file exists, the trojan sends its size as a <param_1>|<size>. If the <param_0>.tu file does not exist, the trojan creates the file <param_0>tut, writes the string, which consists of 32 zeros, into it and deletes the file. Depending on the command execution results, the trojan can send various types of responses to the server. In cases of failure at any given step of the command execution, the trojan sends <param_1>|<code>, where <code> can have a value from 01 to 05. 0x03 Creates an application process with the <param_0> name and <param_1> command Runs a separate thread that lists the processes and sends the information about them to the C&C server one by one. Before the listing, the packet with the 0x17 ID and a DWORD 0x47 payload is sent to the server. It is sent as follows: WCHAR proc_name[30]; WCHAR self_module_path[260] } Herewith, self_module_path is only sent when the process is running in the WOW64 environment. Otherwise, this string is filled with 0 values. 0x05 Launches the cmd.exe thread. It creates the cmd.exe process with the input-output redirection into the pipes. After the process is created, it sends a packet with the 0x17 ID and a 0x3D payload in case of a successful connection, or 0x3E in case of a failure. Herewith, the trojan receives the input parameters of the command line from the message using the GetMessage function. The results are sent with the 0x06 ID. 0x06 Input of the parameters for the cmd.exe. Using PostThreadMessage, it sends the message 0x464 to the cmd.exe thread and puts the data from the command into Ends the connection, sending a packet with the 0x17 packet ID and a DWORD 0x3E payload prior, then deletes its service and executable file. 0x09 Opens the file for writing from the end and writes the buffer received in the command into it. Command’s parameters: · param_0 — name of the file; · param_1 — unknown value; · param_2 — buffer size; · param_3 — special flag; if it equals 1, then the file must be moved; · param_4 — a buffer for a writing. It adds a .tu extension to param_0, opens (or creates) the resulting file for writing, places the pointer to the end of the file and writes a param_4 buffer. If param_3 equals 1, then it deletes the param_0 file and renames the file <param_0>.tu into param_0. 0x14 Gets the size of the file specified in the command. 0x15 Reads the 0x1000 bytes from the param_0 file, starting with param_2, and sends the results with the 0x15 ID to the server. 0x16 Deletes the specified file. If successful, it sends a packet with the 0x17 ID and a DWORD 0x1F payload to the server; in case of an error, a packet with the 0x20 ID is sent If the first DWORD of the command’s body equals 1, the trojan goes to sleep for 1 second; if it equals 2, the trojan closes the file handle. 0x18 Ends the process with PID specified in the command. In return, the C&C server sends the packet with the 0x17 ID. If successful, DWORD 0x0B is sent along with this ID. If failed, 0x0C will be sent. 0x19 Gets information about disks. Upon receiving this command, the trojan checks all the disks available from the letter A to the Z and sends information about each of them to the C&C server. The disk information is sent as a the following structure: Herewith, if the disk found has a DRIVE_REMOVABLE type or a DRIVE_CDROM type, the trojan indicates the value 1 in the cdrom_or_removable parameter. Prior to listing the disks, the trojan sends the disk_info structure with the dword_1 value, which equals 1, as well as other parameters, which are equal to 0. 0x20 Gets the file list in the specified folder. The list is formed as lines of the <file_name>;<file_size>;<last_write_time(YYYY-MM-DD hh:mm:ss)>;<is_dir> format, which are separated by the | symbol. If the object represents the directory, the <is_dir> value is indicated as 1; if the object represents a file, the 0 value is indicated. Creates the TCP tunnel. This command has the host parameters to connect to. The parameters come as the following structure: char hostname[66]; Where index is the tunnel index. After connecting to the host, the trojan receives a block with the size of 0x400 bytes and sends it to the C&C server as the following structure: After the last block is sent, the trojan sends the index with the 0x24 ID. 0x23 Sends the data to the tunnel. The C&C server sends the structure tunnel_data, and the trojan sends the data into the tunnel with the tunnel_data.index index. 0x24 This command contains tunnel index that needs to be closed. 0x25 This command contains the structure tunnel_host. The trojan creates a TCP socket, binds the port to tunnel_host.port, and awaits for the incoming connection. Upon receiving the incoming connection, the trojan sends a zero-length packet without a payload and 0x25 to the C&C server. After that, it receives the data from the new connection, along with the 0x26 ID and sends them to the C&C server. 0x26 The command contains a tunnel_data structure. Upon receiving this command, the trojan sends the data to the connection it received in the 0x25 command. 0x28 Ends the thread sending the heartbeats. 0x29 Moves the file from param_0 to the param_1. 0x31 Creates a desktop screenshot. 0x33 Gets the list of running services as strings <service_name>;<service_display_name>;<current_state>, separated with the | symbol. 0x34 Services management command. If param_0 has a 0 value, the trojan stops the param_1 service. If param_0 has a 1 value, the trojan launches the param_1 service. Upon receiving the command with the 0x17 ID, the trojan closes the file handler, which is stored in the global variable. This file is used only twice: once upon receiving the command, specified earlier, and once in the journal writing function. File handler closing: Writing to the journal (logging): Table of the identifiers of the log entries types rec_id identifier Error code Log entry type Description 0x01 0 No entry Written at the beginning of the execution 0x0E 0 The name of the C&C No entry Added upon C&C server connection error 0x07 0 Proxy server name No entry Added before connecting to the proxy No entry Added upon proxy 0x0A 0 CONNECT HTTP/1.1\r\nProxy <proxy_auth>\r\n\ HTTP/1.1\r\n\r\n, if proxy server authorization parameters are missing HTTP-proxy connection No entry Added if there is a proxy server connection No entry Added upon receiving an empty reply from a Proxy server response Added upon successfully connecting to the proxy server 0x05 GetLastError() No entry Added when a HKCU\Software\Mic rosoft\Windows\Cu registry key opening A not find proxy address string which is encoded inside the body of the trojan. No entry Added when a system information packet is sent through the proxy server, whose address is encoded inside the Added when system information is sent through the proxy server: from the registry section HKCU; received using WinHTTP _SID> registry section 0x02 0 No entry Added when system information is sent directly to the server 0x10 0 No entry Added after system information is sent to the server and before a thread with heartbeats is launched Trojan.Mirage.1 Trojan.Mirage.1 is a multi-component backdoor trojan designed for Windows 32-bit operating systems. It is used for unauthorized control of infected computers and accessing information stored on them. The infection is implemented through a loader injection into the valid running system process. The payload unpacking and arbitrary code execution is done on the infected computer’s RAM. Operating routine Trojan.Mirage.1 has the following file suite: · WmiPrvServer.exe — file with a valid HP digital signature: CN=Hewlett-Packard Company OU=Hewlett-Packard Company OU=Digital ID Class 3 - Microsoft Software Validation v2 O=Hewlett-Packard Company L=Palo Alto · rapi.dll — the loader. It loads on the WmiPrvServer.exe process using the DLL Hijacking method, · cmdl32.dat — the encrypted shell code with the payload, · config.dat — the encrypted configuration. Rapi.dll loader module The loader module is injected into the WmiPrvServer.exe process using the DLL Hijacking. The program receives the GetProcAddress function address through the PEB (Process Environment Block) structure by comparing the strings. After that it receives the addresses of the necessary imported functions: Next, the cmdl32.dat file, located in the same directory from where the parent process of the trojan was launched, is read. The loader decrypts the file using the XOR operation with the 0x88 byte and jumps to the decrypted buffer using the JMP instruction. The encrypted shellcode cmdl32.dat At the start, the shellcode calculates the size of the payload. The beginning of the payload is found through the call of the last shellcode function, and its end is determined by the Next, the program receives the list of necessary imported functions. Through the PEB structure, the trojan locates the GetProcAddress function, which it instantly uses to get the LoadLibraryA function address. The search for the rest of the imports is done through these two functions. Next, Trojan.Mirage.1 decrypts the payload using the XOR operation with the 0xCC byte, loads the resulting MZPE file onto the memory and calls the mystart exported function. The payload module represents a dynamic library with the exported functions: Below, we will dissect two major functions responsible for the trojan operation: mystart At the beginning, the %TEMP%\\installstat.tmp file is checked to be present. If it exists, Trojan.Mirage.1 reads a proxy server address from it and then deletes this file. The c:\\programdata\\Tmp\\cmd32\\cmd32 path is used as a home directory, herewith the creation, modification and access date for the c:\\programdata\\Tmp\ \cmd32\\cmd32 and c:\\programdata\\Tmp\\ folders are copied from the %WINDIR% \\System32\\winver.exe file. The Global\\dawdwere4de2wrw mutex is used to ensure that only one instance of the malware is running. At this stage, the program checks for the presence of the avp.exe and avpui.exe processes. If even one of them is found, then throughout its further operation the trojan will additionally verify the presence of the object with the Global\\v2kjgtts1 event name. If it locates it, the trojan will halt its further operation. Trojan.Mirage.1 can operate in 3 modes. While operating as a service, it checks if the event object with the Global\\v2kjgtts1 name exists. If the event object is missing, it copies its files from the current directory onto c:\\programdata\\Tmp\\cmd32\\cmd32 and injects either into the iexplore.exe process (for the Windows systems, starting from Windows Vista and higher) or into the explorer.exe process (for the Windows systems below Windows Vista). While operating in the context of the explorer.exe or iexplore.exe processes, it deletes its files from the %TEMP% directory, checks if the Global\\dawdwere4de2wrw mutex is present and creates it if missing. If the trojan is launched with elevated privileges, it creates the Windows Event Update service; otherwise, it configures its autorun through the [HKCU\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows] 'Load' registry key and proceeds to execute its main functions. For the rest of the cases, Trojan.Mirage.1 checks for the Global\\dawdwere4de2wrw mutex. If it is missing, the malware injects either into the iexplore.exe process (for the Windows systems, starting from Windows Vista and higher) or into the explorer.exe process (for the Windows systems below Windows Vista). OnWork Function After receiving the imported functions, the application proceeds to execute its main functions, skipping installation onto the system routine. It reads the c:\\programdata\\Tmp\\cmd32\\cmd32\\config.dat file and decrypts it using the following algorithm. The configuration has the following structure: char cnc_addr[32]; char cnc_port[16]; char interval[16]; char timeout[16]; char unk3[16]; _DWORD unk4; char trojan_name[16]; _DWORD unk5; wchar_t campaign[32]; }; Next, Trojan.Mirage.1 collects various information about the infected computer and forms the following structure: wchar_t version[32]; wchar_t pc_name_user[64]; wchar_t bot_ip[64]; wchar_t macaddr[64]; The %s-v1.0-%s line is stored in the version field; with that, the v1.0 value is hardcoded in the analyzed sample, while the two other lines, trojan_name and campaign, are taken from the settings. Next, an attempt to connect to the C&C server is made. To do so, the trojan checks for the proxy server settings in the [HKCU\\Software\\Microsoft\\Windows\ \CurrentVersion\\Internet Settings] 'ProxyEnable' and [HKCU\ \Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings] 'ProxyServer' registry entries. If settings are found, the trojan uses the corresponding proxy server in its further requests. Trojan.Mirage.1 connects to the C&C server listed in its configuration and sends the _DWORD dword0; // 'f' _DWORD dword4; // random value _DWORD dword8; // random value _DWORD dwordC; // random value wchar_t text[256]; // "Neo,welcome to the desert of real." }; In response, it receives the following commands to execute: · 0 — send information about the infected computer; · 1 — run the plug-in designed to work with the file system; · 2 — run the plug-in designed to work with the command shell; · 5 — run the plug-in to work with the processes; · 6 — run the plug-in to work with the command shell on behalf of another user; · 7 — run the keylogger plug-in; · 51 — send information about the infected computer; · 52 — download an update for the trojan; · 53 — disconnect from the server; · 54 — disconnect from the server; · 200 — send the information about storage devices installed in the system; · 201 — send the directory listing; · 202 — delete a file; · 203 — move a file; · 204 — upload a file to the server; · 205 — download a file from the server; · 206 — create a directory; · 207 — run a command with the cmd.exe; · 300 — send a list of the processes in the infected system to the server; · 301 — kill a process with a specific identifier; · 400 — upload an event log of the keylogger to the server. C&C server connection protocol The HTTP protocol is used to connect the malware with the C&C server. The requests have the following format: POST url HTTP/1.1\r\n Accept: */*\r\n Accept-Language: en-us\r\n User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)\r\n Proxy-Connection: Keep-Alive\r\n Content-Length: %d\r\n Content-Type: application/x-www-form-urlencoded\r\n Encoding: gzip, deflate\r\n Host: %s:%d\r\n\r\n Where <cnc_addr> is the C&C server address; <cnc_port> is the port of the C&C server; <id> is a random string of lower-case letters of the Latin alphabet. The unique <id> is generated for each request. The data for the POST-request and the response is encrypted with the following algorithm: for ( i = 0; i < data_size; ++i ) request[req_header_len + i] = (i ^ 0x7C) + data[i]; The first DWORD in the server response is the identifier of the command, which should be executed by the bot. The rest of the buffer can contain the additional parameters for this command. The plug-in designed to work with the command shell For the input/output redirection from the cmd.exe process, the following three files are used: · %TEMP%\\cache\\sysin_%d.log · %TEMP%\\cache\\sysout_%d.log · %TEMP%\\cache\\systemp_%d.log Where %d is a random number, which is the same for all three files; it is generated at the time of the plug-in launch. If the plug-in has been launched with command 6, the command buffer should contain the domain and user login and password, from under which the command shell is being launched. After that, the trojan launches the command shell with the input/output redirection onto the files, mentioned earlier. The contents of the sysout_%d.log file will be sent to the C&C server, and the response will be stored in the sysin_%d.log file. Trojan.Misics.1 A multi-functional trojan backdoor for 64-bit Microsoft Windows operating systems. Its main components are the loader and the payload that functions in the computer's RAM. Code obfuscation and two-step payload encryption are used to hide traces of malware presence in the system. The backdoor is designed for establishing an encrypted connection with the C&C server and for unauthorized control over an infected computer. Operating routine The loader is a dynamic library with Rundll32Entry and ServiceEntry exported functions. During the infection process, it is installed in directory C: \ProgramData\MISICS\MISICS.dll. It can be launched as a service using svchost.exe or execute its own code using rundll32.exe. During initialization, it checks which way the process was launched. The trojan restarts using rundll32.exe with the -auto key, in case it was launched differently. For obfuscation purposes, a large amount of garbage code is used, making it difficult to detect the original instructions. The search for all utilized APIs is performed via the PEB (Process Environment Block) in the kernel32.dll and user32.dll libraries by name, which results in the API address being entered in the function table. Next, the program loads the <loader name>.crt file into memory, which is an encrypted payload. The first 4 bytes of the file are used to generate the decryption key, and the rest is decrypted. The key is a checksum of the first 4 bytes calculated using the CRC32 algorithm. The initial CRC value is set in the code 0xAC1FD22B. To decrypt each byte of data, the CRC result from the DWORD is calculated, which contains the sequential number of the decrypted byte. The CRC value from the previous step is the initial CRC value for the next for i in range(0x100): x = i for j in range(8): if x & 1: x = ((x >> 1) ^ 0xEDB88320) & 0xffffffff else: x = (x >> 1) & 0xffffffff s[i] = x def crc32(crc, data): for i in range(len(data)): crc = ((crc >> 8) ^ table[(crc ^ ord(data[i])) & 0xff]) & 0xffffffff return crc def decrypt(data): s = '' key = crc32(0xAC1FD22B, data[:4]) j = 0 for i in range(4, len(data)): key = crc32(key, struct.pack('<I', j)) s += chr((ord(data[i]) - key) & 0xff) if __name__ == '__main__': with open('MISICS.dll.crt', 'rb') as f: data = f.read() with open('payload', 'wb') as f: f.write(decrypt(data)) After decryption, the trojan checks the value of the first DWORD of the decrypted data. If it is not equal to 0x13AB7064, the decryption is considered incomplete. The 0x318 byte configuration is located at the beginning of the decrypted data, and the payload is located right after it. #pragma pack(push,1) _DWORD sig; // 0x13AB7064 _BYTE payload_entry_func_name[260]; _BYTE payload_entry_func_arg[260]; _BYTE payload_exit_func_name[260]; #pragma pack(pop) The field of the isPE structure can take the following values: · 0 — the payload is a shellcode, · 1 — the payload is MZPE file (.exe), · 2 — the payload is MZPE file (.dll). If bCreateDllExitEvent is equal to 1, the trojan creates an event signaling the successful completion at the end of operation. The trojan also calls the payload_exit_func_name function of the payload. In the studied sample, the payload is a shellcode. Debugging strings generated on the stack: · Get Payload File Name.\n · ServerLoadPayload()\n · Get Module File Name.\n · Read Payload File.\n · Switch to payload directory.\n · Verify Payload Data.\n · Decrypt Payload Data.\n · Load PE.\n · Create DllExit Event.\n · Get DllExit Export Function.\n Example of creating a rundll32.exe: Obfuscation is a frequent inclusion of the one-type code that does not affect the performance of the main functions. There is also a lot of meaningless calls added: GetVersion(), SetLastError(), GetLastError(), GetSystemTime(), SystemTimeToFileTime(), OutputDebugString(), and GetTickCount(). Some OutputDebugString calls provide useful debugging information. Another distinctive feature is the large number of allocations of small memory blocks using the new function with simultaneously release. Payload The main body of the shellcode and its configuration are encrypted using a simple algorithm based on the XOR operation. Decryption is performed by the part of the shellcode that was previously decrypted by the loader. 