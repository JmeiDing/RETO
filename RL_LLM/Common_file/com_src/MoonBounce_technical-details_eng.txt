Technical details of MoonBounce’s implementationLearn more on kaspersky.com #bringonthefutureMoonBounce UEFI ImplantThe rogue CORE_DXE component was patched by the attackers to incorporate an additional, malicious payload, which represents what we refer to as the MoonBounce implant.MD5SHA1D94962550B90DDB3F80F62BD96BD98586BFB3634F6B6C5A114121FE53279331FF821EE1ESHA25674B75B1A1375BA58A51436C02EB94D5ADCD49F284744CF2015E03DA036C2CF1ALink timeFriday, 18.07.2014 03:29:55 UTCFile type64-Bit EFI_BOOT_SERVICES_DRIVERFile size1.698 MBFile nameCORE_DXEThis payload was appended to an unnamed section that follows the .reloc section and contains both shellcode and a malicious driver that are introduced in memory through a multistage infection chain during boot time. The driver, which is supposed to run in the context of the Windows kernel during its initialization phase, is in charge of deploying user-mode malware by injecting it into an svchost.exe process, once the operating system is up and running.The aforementioned infection chain starts with a set of inline hooks at the beginning of several functions in the EFI_BOOT_SERVICES structure. This structure, which is a part of the CORE_DXE image itself, contains a table of pointers to routines (referred to as Boot Services) that are callable by subsequent components in the boot sequence, such as the DXE drivers, boot loader and OS loader. Hooking functions in this table facilitates the propagation of malicious code to other boot components during system startup.The hooked functions in the underlying EFI_BOOT_SERVICES table, namely AllocatePool, CreateEventEx and ExitBootServices, have their first 5 bytes (typically referred to as the function’s prologue) replaced with a call instruction to a single malicious hook. The hook’s code checks the first bytes after the call instruction and, based on predefined byte patterns, can deduce the source function triggering its execution. Based on this trait, it can dispatch the flow to successive handlers corresponding to each of the hooked functions.Example of a hook installed at the beginning of the AllocatePool boot services1The steps taken in the infection chain, as a result of deploying the above hooks, are depicted in the following diagram with accompanying explanations:Flow of MoonBounce execution from boot sequence to malware deployment in user space1. The first Boot Services function invoked in CORE_DXE after the EFI_BOOT_SERVICES structure initialization isAllocatePool, which diverts execution to its corresponding handler within the hook function.22. AllocatePool’s handler:• Restores the original prologue bytes that were previously modified by the attackers to “48 89 5C 24 08” (corresponding to the instruction “mov [rsp+8], rbx”) and saves the state of the registers rcx,rdx,r8,r9,rsi and rdi (some of which are typically used to pass function arguments).• Calls AllocatePool (which is now unhooked) with pre-configured parameters that are intended to allocate a buffer in memoryand assign it with shellcode used at later stages of the infection.• Restores the saved state of the registers and passes control back to the beginning of AllocatePool, which is now executedwith the original arguments with which it was invoked in the first place.3. The next Boot Services function invoked in CORE_DXE is CreateEventEx that diverts execution to its handler within theAllocatePool’s hook logichook function.4. CreateEventEx’s handler:• Restores the original prologue bytes that were previously modified by the attackers to “48 8B C4 48 89” (corresponding to the instructions “mov rax” and “mov [rax+8], rbx”) and saves the state of the registers rcx,rdx,r8,r9,rsi and rdi (some of which are typically used to pass function arguments).• Calls the now unhooked CreateEventEx with predefined arguments to register a callback for an event that represents alegacy boot (designated with the GUID {2A571201-4966-47F6-8B86-F31E41F32F10}, i.e. gEfiEventLegacyBootGuid). In that case, the callback is responsible for passing control to the shellcode set up in AllocatePool’s hook.• Restores the saved state of the registers and passes control back to the beginning of CreateEventEx, which is now executedwith the original arguments with which it was invoked in the first place.3CreateEventEx’s hook logic5. The boot sequence continues, passing control to the Windows OS loader. At one point, this loader calls the hooked function ExitBootServices, which is supposed to hand control over to the OS loader and eliminate the dependency on the firmware- based Boot Services functions.6. Execution is diverted to the ExitBootServices handler within the hook previously set up in CORE_DXE.The hooking of ExitBootServices in particular was described as a technique in the Vault7 leaks.7. The ExitBootServices handler conducts the following actions:• Restores the original prologue bytes that were previously modified by the attackers to “48 89 5C 24 08” (corresponding to theinstruction “mov [rsp+8],rbx”).• Takes the previous return address from the stack (the first address after the call to ExitBootServices) and searches for the byte pattern “41 55 48 CB” (corresponding to the instructions “push r13” and “retfq”) within a region of 0x158878 bytes after it. These bytes designate the end of the function OslArchTransferToKernel in the Windows OS loader image (typically named winload.efi or osloader.exe and residing in the ESP partition on disk).• Copies 0x229 bytes of shellcode to address 0x98000 in memory. • Replaces the bytes starting with “48 CB” (retfq) at the end of the OslArchTransferToKernel function to E9 <offset_to_0x9800_shellcode>, which is essentially a jump to the shellcode that was just copied to 0x9800.• Restores the saved state of the registers and passes control back to the beginning of the now unhooked ExitBootServices,which is executed as it was originally intended in flow of the Windows OS loader.4ExitBootServices’ hook logic8. In the further execution flow of the Windows loader, it invokes the aforementioned OslArchTransferToKernel function, whichpasses control from the OS loader to the Windows kernel. As mentioned in step 7, the last bytes of the function are replaced, diverting execution to a formerly allocated shellcode that effectively serves as a hook for OslArchTransferToKernel.9. The OslArchTransgerToKernel hook:• Locates the image base of ntoskrnl.exe in memory. • Resolves function addresses exported by ntoskrnl.exe, through which it uses a name-hashing algorithm with the followingequivalent logic:def fn_name_hash(name): for ch in name: index += ord(ch) name_hash += index return (name_hash << 16) | indexThe compared function name hashes and their corresponding resolved functions are:• 0x42790710 – ExRegisterCallback • 0x2802057D – ExAllocatePool • 0x1C88047D – MmMapIoSpace• Changes the Characteristics field in each section header of ntoskrnl.exe’s image in memory:• The IMAGE_SCN_MEM_DISCARDABLE bit gets disabled (the section cannot be discarded); • The IMAGE_SCN_MEM_EXECUTE, IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_NOT_PAGED bits getenabled.• Copies 0xCC bytes of another shellcode to the virtual address of the ntoskrnl.exe’s relocation directory. • Sets up an inline hook at the beginning of ExAllocatePool with a call instruction to the copied shellcode by placing thebytes E8 <offset_to_shellcode> at the beginning of the function and saving the original bytes in a designated buffer.510. Control is passed to the Windows kernel, which then invokes the hooked ExAllocatePool and in turn diverts execution to itsCode that set up a hook in the ExAllocatePool function within ntoskrnl.exehook, which was set up in the previous stage.11. The ExAllocatePool hook:• Verifies if the hook was previously executed by checking a predefined global flag. If not, the flag is set to designate that thehook was run so that any subsequent execution of ExAllocatePool will invoke the original function flow.• Calls MmMapIoSpace to map the driver mapping shellcode, which was set up during step 2, to the virtual address space ofthe Windows kernel.• Jumps to the address of the now mapped shellcode, passing it the following arguments on stack: • Pointer to a buffer with the saved ExAllocatePool prologue bytes • Base address of ntoskrnl.exe • Pointer to ExAllocatePoolExAllocatePool hook logic612. At this point, the main shellcode set up in the early stages of the infection chain and mapped to the virtual memory address space of the kernel in the previous step gets executed. The purpose of this shellcode is to map a raw PE image of a malicious driver (that is, appended at the end of the shellcode bytes) in memory and pass control to its entry point. To achieve this goal, the shellcode:• Checks if the buffer with the saved prologue bytes of ExAllocatePool passed to it in the first argument is equal to0x6F4EB841 (the original bytes in ExAllocatePool that were modified when it was hooked), in which case it resets the WP bit in the CR0 register in order to be able to write to read-only pages in memory and restores these original bytes to the beginning of ExAllocatePool (which has its address provided as the third argument of the shellcode), effectively unhooking it. After that, the shellcode restores the previous state of CR0 before it was modified.• Resolves exported functions from ntoskrnl.exe that are essential for the subsequent PE mapping. The function addressresolution code makes use of yet another name-hashing algorithm, which is outlined in the equivalent logic below:def ror13(x): return 0xFFFFFFFF & ((x >> 13) | (x << 32 – 13)) def fn_name_hash_ror13(f_name): f_hash = 0 for i in f_name: f_hash = ror13(f_hash) f_hash += ord(i) f_hash = ror13(f_hash) return f_hashThe functions resolved in this phase and their corresponding name hashes are the following:• 0x0311B83F – ExAllocatePool • 0x0ADC68C7 – MmGetSystemRoutineAddress• Maps the malicious driver image to the kernel memory with the following common PE-loading steps:• Allocates space for the image with the now unhooked ExAllocatePool function • Copies headers and sections to their corresponding virtual addresses in memory • Applies relocations • Resolves imports by getting each name in the import table, initializing its string with RtlAnsiString andRtlAnsiStringToUnicodeString, and passing the result as an argument to MmGetSysteRoutineAddress, following which the argument string is freed with RtlFreeUnicodeString.• Finally, control is passed to the entry point of the malicious driver.For clarity, steps 13-16, which are taken by the malicious driver and the user-mode malware it deploys, are explained in detail in the following sections.MD5SHA12228E682B2686DBE0330835B58A6F2BF (x86) 934D06720F4CB74069A870D382AC5045 (x64)22A4BD6BFD580C3A2025B1A91F8EF1677FECA360 (x86) 3D2E6F0C3B6FD0FB44966ADB4F13679E4091D851 (x64)SHA256707B8684009665742B9C6D801C12B9803F33FC518CB6BF513B4FA15A9E72E106 (x86) F17C1F644CEF38D7083CD6DDEB52BFDA2D36D0376EA38CC3F413CAB2CA16CA7D (x64)Link timeTuesday, 18.12.2018 03:48:33 UTC (x86) Tuesday, 18.12.2018 03:48:24 UTC (x64)File typeFile sizePE32 executable (native) Intel 80386, for MS Windows PE32+ executable (native) x86-64, for MS Windows34.63 KB (x86) 37 KB (x64)File nameNone7The purpose of the malicious driver is to inject user-mode malware into a Windows service of the network services group, thereby allowing it to have access to the internet. This is achieved by first having the driver register a callback using the PsSetLoadImageNotifyRoutine API, which is invoked when the Windows loader maps a PE image to memory (as outlined in step 13 of figure 1). This callback in turn verifies that the inspected image is kernel32.dll and the underlying owning process is executed with the command line: ‘SVCHOST.EXE -K NETSVCS’ or ‘SVCHOST.EXE -K NETSVCS -P’.Conditions to locate the target svchost.exe process for injection by MoonBounce’s driverIf the above conditions are met, the driver continues to inject an embedded PE image, corresponding to a user-mode malware stager, to the matching svchost.exe process (as outlined in step 14 of figure 1). The injection leverages the Windows APC (Asynchronous Procedure Call) mechanism through the following actions:• The driver enqueues a kernel mode APC routine, which will run in kernel mode with APC_LEVEL IRQL; • The kernel APC routine initializes the following data structure:OffsetField0x00x280x8000xA000x1000A table with pointers to various fields in the current structure and Windows API functions that are used by the PE mapping shellcodePE mapping shellcode used to load the raw user mode stager PE to memoryBuffer with the drop zone URL carrying the payload to be downloaded by the stagerPaddingBuffer with the raw image of the deployed user mode stagerThe first field, which we will refer to as the mapping shellcode argument, shows the following layout:OffsetField0x00x80x100x180x20Pointer to the buffer with the user mode stagerPointer to the buffer with the C2 URL containing the payload to be downloaded by the stagerPointer to VirtualAllocPointer to LoadLibraryAPointer to GetProcAddress8The kernel routine initializes a WORK_QUEUE_ITEM structure with a pointer to a worker routine and an argument structure with the following layout:OffsetField0x00x80x100x18Pointer to PE mapping shellcodePointer to the PE mapping shellcode argument described abovePointer to the KTHREAD object corresponding to the current thread executing in the context of the injected processPointer to a notification eventIt then calls the ExQueueWorkItem with the above structure in order to insert the worker routine to a system wide queue.Initialization of a WORK_QUEUE_ITEM structure used to schedule the execution of a worker routine in kernel space• The Windows kernel has a designated system thread that picks up the previously enqueued task and executes its correspondingroutine, passing it a pointer to the argument structure described above. In this case, the executed routine queues the PE-mapping shellcode with its own argument structure to the APC queue of the current thread running in the context of the injected svchost.exe process.Worker routine injecting the malicious MoonBounce user-mode stager to an svchost.exe instance using APC injection• Once the aforementioned user-mode thread within svchost.exe is scheduled to run, its execution is preceded by the PE-mapping shellcode, which uses its argument structure to load the malware stager PE image to svchost.exe’s memory address space and invoke its entry point (as outlined in step 15 of figure 1).9User Mode Malware StagerMD5SHA18DB7440B39761EA8ED75B7870542E1F3E21483618EEAE7CC476BC67BF768069572BE7FE0SHA2564CC7A14BC2E40BE93BBDF6F871430F08C3335E893519D75EA37C66942E1EB7FALink timeTuesday, 11.12.2018 09:25:17 UTCFile typePE32+ executable (DLL) (GUI) x86-64, for MS WindowsFile size66.5 KBFile nameNoneThe user-mode malware stager, which is injected to an svchost.exe process by the malicious driver, is a DLL packed with a common software tool called MPRESS. It operates in a similar fashion to UPX, whereby the original sections of the PE are compressed into a new section called .MPRESS1 and the code for unpacking is appended into another generated section named .MPRESS2. It gets executed during runtime in order to decompress the data and pass control to the original entry point within.After unpacking, the malware executes a basic staging component that reaches out to a C2 URL and obtains a PE image. The DLL receives an argument from the driver in the lpReserved parameter of the DllEntryPoint, which should contain a pointer to a C2 URL. The same argument can contain additional optional data elements that can be used in a number of ways throughout execution. These are laid out in a structure of the following form:OffsetField0x00x11c0x1800x1c00x1e0C&C URL (may also contain a scheduling related argument)User-AgentProxy addressProxy usernameProxy passwordTo receive a further payload to run, the malware:• Runs a system time-dependent scheduling algorithm that postpones execution until reaching a predefined deadline value, at which point the downloading logic is initiated. This value ought to be provided as part of the aforementioned DLL argument; however, we did not observe it being passed by the driver we analysed.• Sets up an optional User-Agent or uses the default string “IE” instead. Once again, the driver in our case did not pass anyparticular argument to use in this field; therefore, it is expected to be the default value.• Registers a callback function with the InternetSetStatusCallback API, which detects whether the system makes use of aproxy, in which case the malware can use the proxy configuration provided in the DLL argument to issue a request.• Sends a GET request to the C2 URL, expecting to receive a raw PE image as a response. • Maps the retrieved image to the current memory address space and invokes its entry point.Kaspersky’s threat research and reports: www.securelist.com Kaspersky’s blog. Business-related topics: business.kaspersky.com Enterprise security you can trust: kaspersky.com/enterprise-securitykaspersky.com.IIS 